Linux

an Operating system is a collection of software that manage hardware resources and provides the enviroment where applications run.
the Operating System allows applications to store information, intract with users, etc...

Linux distribution is a collection of software and applications bundle together and distributed as an single 
Operating System
for example, one Linux distribution might come with one particular web browser installed,
while another Linux distribution might come with another web browser installed by default.
so the specific peice of software used to do that, might be different

woeds: Distribution = Distro = Flavor

Linux Kernel is the core or the heart of the Operating System.
it's the layer which is sits between hardware and applications.
however to have a useful Operating System, we need other components in addition to Kernel
these components can include system libraries, graphical user interfaces, email utilities, web browsers and so on...

A Linux Distribution = Linux Kernel + collection of software that create together an Operating System
most popular Linux distributions are: redhat & Ubuntu

large componies like financial institutions, transportation companies, telecominication, Banks, Airlines, Healthcare organizations,
use redhat
but for personal uses and still working with redhat, CentOS can be recommended.

startups, SaaS, small businesses, Social Networks, Cloud based
Linux Mint, Debian, Mageia, Fedora, openSUSE, Arch Linux, Slackware
-----------------------------------------------------------------------------

Installing VirtualBox on Mac

visit virtualbox.org and install VirtualBox. then install "the unarchiver" from appStore.
now download "CentOS 7" from "https://www.linuxtrainingacademy.com/vdi/"
now that we've downloaded our virtual disck image, 

next we'll create a new container or virtual machine for our CentOS Operating System by clikcking on new.
then we should specify the name, the type, and the version.
we name our virtual machine centosdesktop, it will automatically change the Type and version
as Linux and Red Hat (65-bit). then press continue

the minimum amount of RAM recommended for CentOS is 1024 MB or 1GB
so we use 8192MB or 8GB . then continue

then we use the "Use an existing virtual hard disk file" option.
now we click on the folder icon and navigate where we downloaded our disk image.
then press create, and now we have a virtual machine for centos.
in order to start it, we select the virtual machine on the left and press "start" on above

once CentOS has booted up, we presented with a login screen.
to login as admin user, just click on username. and pass the password as: "adminuser" as well.
and click sign in.

* Download CentOS Project:

in "https://www.centos.org/" click on Get CentOS now,
we have some options here: "DVD ISO" has all the packages we need to install. we click on it and
download the first one in the list.

"Everything ISO" contains compelete set of packages for CentOS. we use it if we want to create a local mirrer of CentOS packages
"Minimal ISO" provide us the very basic CentOS system. it won't install the graphical user enviroment

now that we downloaded "DVD ISO"

in order to start terminal, go to "Applications>Terminal"

-----------------------------------------------------------------------------
* by Terminal

sometimes we want to login by terminal instead of graphical user interface.
if we install a server distribution instead of desktop distribution, we should login by terminal
to exit terminal, just type the word "exit"

-----------------------------------------------------------------------------
* by Network

logging the system by network is likely to use SSH (stands for Secure Show)
SSH is a network protocol. it's premiry purpose is to allow you to connect from one system to another system securely over the network.
in order to connect to a Linux system from mac, we need terminal. once you open up terminal,
you can use the SSH command to initiate the connection

-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
    What is SSH?
    Secure Shell, sometimes referred to as Secure Socket Shell, is a protocol which allows you to connect securely to a remote computer or a server by using a text-based interface.

    How Does SSH Work?
    n order to establish an SSH connection, you need two components: a client and the corresponding server-side component.
    The client uses the provided remote host information to initiate the connection and if the credentials are verified, establishes the encrypted connection.
    On the server’s side, there is a component called an SSH daemon that is constantly listening to a specific TCP/IP port for possible client connection requests.
    Once a client initiates a connection, the SSH daemon will respond with the software and the protocol versions it supports and the two will exchange their identification data.
    If the provided credentials are correct, SSH creates a new session for the appropriate environment.
    The default SSH protocol version for SSH server and SSH client communication is version 2.

    How to Enable an SSH Connection
    Since creating an SSH connection requires both a client and a server component, you need to make sure they are installed on the local and the remote machine, respectively.
    Note that Ubuntu does not have SSH server installed by default.

    How to Install an OpenSSH Client
    To check if the client is available on your Linux-based system, you will need to:

    1. Load an SSH terminal. You can either search for “terminal” or press CTRL + ALT + T on your keyboard.
    2. Type in ssh and press Enter in the terminal.
    3. If the client is installed, you will receive a response that looks like this:

        username@host:~$ ssh

        usage: ssh [-1246AaCfGgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]
        [-D [bind_address:]port] [-E log_file] [-e escape_char]
        [-F configfile] [-I pkcs11] [-i identity_file]
        [-J [user@]host[:port]] [-L address] [-l login_name] [-m mac_spec] 
        [-O ctl_cmd] [-o option] [-p port] [-Q query_option] 
        [-R address] [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]]
        [user@]hostname [command]

        username@host:~$

    This means that you are ready to remotely connect to a physical or virtual machine. 
    Otherwise, you will have to install the OpenSSH client:

    Run the following command to install the OpenSSH client on your computer: sudo apt-get install openssh-client
    Type in your superuser password when asked.
    Hit Enter to complete the installation.


    How to Install an OpenSSH Server
    If you first want to check if OpenSSH server is available on the Ubuntu system of the remote computer 
    that needs to accept SSH connections, you can try to connect to the local host:

    1. Open the terminal on the server machine. You can either search for “terminal” or press CTRL + ALT + T on your keyboard.
    2. Type in ssh localhost and hit enter.
    3. For the systems without the SSH server installed the response will look similar to this:

    username@host:~$ ssh localhost
    ssh: connect to host localhost port 22: Connection refused username@host:~$

    If the above is the case, you will need to install the OpenSSH server. Leave the terminal open and:

    1. Run the following command to install the SSH server:  
    $ sudo apt-get install openssh-server ii.
    2. Type in your superuser password when asked.
    3. Enter and Y to allow the installation to continue after the disk space prompt.

        ATTENTION: Mac OS X doesn't have apt-get. There is a package manager called Homebrew that is used instead.
        What Does Homebrew Do?
        Homebrew installs the stuff you need that Apple (or your Linux system) didn’t.
        Install Homebrew:
        Paste that in a macOS Terminal prompt.
        /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
    Use Homebrew to install packages that you would otherwise use apt-get for.
    syntax is like:
    $ brew install python

    now if we run: 
    $ sudo brew install openssh-server ii.

    it says:
    Error: Running Homebrew as root is extremely dangerous and no longer supported.
    As Homebrew does not drop privileges on installation you would be giving all
    build scripts full access to your system.
        
        * Like the error says you shouldn’t use brew with sudo.
        * No Homebrew packages should require sudo for installation.

    How do you run a SSH server on Mac OS X?
    Go to System Preferences -> Sharing, enable Remote Login.
    with doing it, you enable SSH and SFTP servers in Mac OS X.
    so we no longer need to write: $ brew install openssh-server ii.

    Another way to test if the OpenSSH server is installed properly and will accept connections 
    is to try running the ssh localhost command again in your terminal prompt.

    How to Connect via SSH
    you can establish a secure remote connection with your servers. To do so:

    1. Open the SSH terminal on your machine and run the following command:
    $ ssh your_username@host_ip_address
    
    If the username on your local machine matches the one on the server you are trying to connect to, you can just type:
    $ ssh host_ip_address
    
    And hit Enter.

    NOTE: the default username for ubuntu servers is "root".
    for example in order to connect to a have-bought server, we have:
    $ ssh root@144.76.232.50
    or
    $ ssh cn.radfar.net

    2. Type in your password and hit Enter
    3. When you are connecting to a server for the very first time, it will ask you if you want to continue connecting. 
    Just type yes and hit Enter. This message appears only this time since the remote server 
    is not identified on your local machine.
    4. An ECDSA key fingerprint is now added and you are connected to the remote server.


    Here is the example of a connection request using the OpenSSH client. 
    We will specify the port number as well:

    -------------------
    username@machine:~$ ssh phoenixnap@185.52.53.222 –p7654 phoenixnap@185.52.53.222’s password:

    The authenticity of host '185.52.53.222 (185.52.53.222)' can't be established. 
    ECDSA key fingerprint is SHA256:9lyrpzo5Yo1EQAS2QeHy9xKceHFH8F8W6kp7EX2O3Ps. 
    Are you sure you want to continue connecting (yes/no)? yes
    Warning: Permanently added ' 185.52.53.222' (ECDSA) to the list of known hosts. 

    username@host:~$
    -------------------

    You are now able to manage and control a remote machine using your terminal. If you have trouble connecting to a remote server, make sure that:

    - The IP address of the remote machine is correct.
    - The port SSH daemon is listening to is not blocked by a firewall or forwarded incorrectly.
    - Your username and password are correct.
    - The SSH software is installed properly.


    Now that you are able to establish a connection to your server using SSH, 
    we highly recommend a few further steps to improve SSH security. 
    When you leave the setup with the default values,
    it is more likely to be hacked and your server can easily become a target of scripted attacks.

    - Change the default TCP port where SSH daemon is listening. Change it from 22 to something much higher,
    for example 24596. Make sure you do not use a port number that is easy to guess, such as 222, 2222 or 22222.
    - Use SSH key pairs for authentication. They are both safer and also allow logging in without the need to use 
    your password (which is faster and more convenient).
    - Disable password-based logins on your server. If your password gets cracked, 
    this will eliminate the possibility of using it to log into your servers. 
    Before you disable the option to log in using passwords, it is important to make sure 
    that authentication using key pairs is working properly.
    - Disable root access to your server and use a regular account with the su - command to switch to a root user.
    - You can also use TCP wrappers to restrict access to certain IP addresses or hostnames. 
    Configure which host can connect using TCP wrappers by editing the /etc/hosts.allow and etc/hosts.deny files.

    'https://phoenixnap.com/kb/ssh-to-connect-to-remote-server-linux-or-windows'
    'http://osxdaily.com/2011/09/30/remote-login-ssh-server-mac-os-x/'
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------

* Common Directories Structure:
1. "/"      => "Root, the top of the file system hierarchy"
2. "/bin"   => "is where you finds binary files (or excecutable files.) 
                programs are written in source code and this is a human readable text.
                these files will be compiled into machine readable binaries. they're contain 0 & 1
                applications we can run are sometimes located in /bin"
3. "/etc"   => "is where we can find our configuration files. Configuration files control how the 
                Operating System or applications behave"
4. "/home"  => "is where user home directories live. for example sb's home directory would be
                /home/david  - linux systems can and often have multiple users (multiple user accounts)
                so the home directory is where you can separate your data from another account's data."
5. "/opt"   => "is where Optional or third party software lives. opt is for software that is not bundle with 
                the Operating System. for example GoogleEarth will install in /opt"
6. "/tmp"   => "is for Temporary space. most Linux Distribution clear the /tmp at boot time.
                so if reboot the system, all the files in this folder will be gone. so do not keep anything in it
                that you want it long term." 
7. "/usr"   => "this is where User related programs live."
8. "/var"   => "is for Variable data,things of things that changes often
                most notably log files."
each one of these directories can have sub directories.
9. "/boot"  => "Files needed to boot the Operating System"
10."/cdrom" => "when you insert CD, it will rise up.so that is the location where we can access the files in CD-ROMs"
11."/dev"   => "Device files, typically contrilled by the Operating System and the system administrators."
12."/export"=> "Shared files systems"
13."/lib"   => "System libraries"
14."/lib64" => "System libraries, 64 bit"
15."/media" => "used to mount removable media like CD-ROMs"
16."/srv"   => "Contains data which is served by the system"

sometimes we have Applications Directory Structure which are not related to the Operating System.
like:
/user/local/appName/bin
/user/local/appName/etc
/user/local/appName/lib
/user/local/appName/log
-----------------------------------------------------------------------------

* Shell

the shell is the default user interface to the Linux system.
whe we log into the linux server over the network, the shell is the program taht 
is started and access to the default interface to the system.
if you work with the graphical user interface, you should start Terminal to gain access to the shell
the shell is a program that takes the command you feed it, and it executes those commands for you.
we call shell, as a command line interpreter.

when the shell starts, it show a prompt. it stay there and wait to take a coomand from you
it give us some information like: username,name of server, the path, and a dollor sign ($) that means we'te using the system as a normal user.
like: [jason@linuxsvr ~]$
a SuperUser ends with a hashtag (#)
like: [root@snappserver:~]#

the appearance of prompt can be different in different enviroments.

the SuperUser in the linux system is also called root (it's the root account).
this is a different root from the root of the directories.it is a superuser account named root
the root account in the linux system is similar to administrator account in the windows system.
anything that can be done in the Linux system can be done by the root user.
normal user can only do some sub orders things that root account can do 

applications which are in the servers, typically needs the root access to get started. for example you need root access to
in order to start a webserver

~jason  = /home/jason
~pat    = /home/pat
~root   = /root
~ftp    = /srv/ftp

prompt can expand to multiple lines as well.like:

[Mon 14/02/18 18:22 EST][pts/0]
<jason@linuxsvr:~>
zsh  14 %
-----------------------------------------------------------------------------

* Basic Linux Commands

ls(or "ls -l"),cd,pwd(display the present working directory),cat(Concatenates and displays files)
echo(display arguments to the screen),man(display the online manual), exit(exit the shell or your current session),clear

$ cat sales-report.txt      // shows the content of a file
We sold lots of wodets this week!

echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin

$ man ls    // it used for showing how to use a particular command

*** in order to view next page of information, just press spacebar
*** to exit from this part, press "q"

wiriting "$ cd" with nothing in front of it, take us back to home Directory

when using the man command, there are some tips we should aware of:

"Enter"     Move down one line
"Space"     Move down one page
"g"         Move to the top of the page
"G"         Move to the bottom of the page
"q"         Quit
-----------------------------------------------------------------------------
Enviroment variables store information.they're Storage location that has a name-value pair.
and they're typically uppercase and we can see the content of them by writing 
$ echo $VAR_NAME

PATH is an enviroment variable which cintrols the command search path. it contains a list of directories.
for example when we write:
$ echo $PATH
it returns sth like:
-------------------------
/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/share/dotnet: 
/Users/armanfeili/code/java/Az\ system/Az\ system/scripts/javabaci :
/Library/Frameworks/Mono.framework/Versions/Current/Commands
-------------------------
so in this example,when we execute a command line, "/user/local/bin" will be searched first.
if the command didn't have found, it search for "/user/bin" then, "/bin", then ...

if we want to know the location or the full path to the command that you're executing, use the which command.
like:

$ which cat
/bin/cat
-----------------------------------------------------------------------------

many commands have been provided by --helo or -h command line.

if we're not sure which command we use, we can say:
$ man -k SEARCH_TERM
-----------------------------------------------------------------------------

work with directories:

directories can be accessed by their name, full path, or shortcuts.

.           = This directory  (the current directory)
..          = The parent directory (the directory above the current directory)
cd -        = go to previous directory that we were working with.
/           = the directory separator. directories gets end with slash  =>  home/folder1 = home/folder1/
./command   = Execute command in this dir
$ echo $OLDPWD => this enviroment variable holds the directory that we were previously in.
like:
-------------------------------
$ echo $PATH
/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/share/dotnet: 
$ which cat
/bin/cat

so

$ cat sales.data
returns: week 1, 123
         week 2, 456
         week 3, 789

but we can say this instead and get the same result:

$ /bin/cat sales.data
returns: week 1, 123
         week 2, 456
         week 3, 789

or we can give it a full path:
$ /home/json/my-cat/cat
This is my cat. Meow.

-------------------------------

mkdir                = creates a directory
mkdir [-p]           = creates a parent directory (used for creating multiple nested directories)
                       like: mkdir [-p] one/two/three
rmdir                = removes a directory => it only removes directories which are empty (with no contents)
rm -rf directoryName = remove a directory with all it's files

*** in Command line THERE IS NO UNDO
-----------------------------------------------------------------------------

viewing file directories in details is possibility with "$ls -l"

$ ls -l
-rw-rw-r--     1 armanfeili  staff   2017119 Sep 16  2018 torrents.zip

Permissions                        -rw-rw-r--
Number of links                    1
Owner name                         armanfeili
Group name                         staff
Number of bytes in the file        2017119
Last modification time             Sep 16 2018
File name                          torrents.zip


** files or directories that begin with a period or dot, are considered hidden files
so by writing ls, they won't display. in order to see hidden files, we should add "-a" to "ls"
by writing "ls -l -a" we have a long list of all files.
instead of "ls -l -a" we can use "ls -la" or "ls -al"

we can use "ls -F" to show the file types
/           means Directory
@           means Link      // a link is a points to the actual file or directory and can be used to create a shortcut
                            // it also used for indicate the current version of an application
*           means Executable

let's see:
----------------------------
$ ls
-----
Az payegah			java.iml
Az system			java.rar
Eclipse.SDK.4.7.1.x64		lessons
Material Theme			package com.docx
Mehdi_haeri			pdf lessons
-----
$ ls -F
-----
Az payegah/			java.iml
Az system/			java.rar
Eclipse.SDK.4.7.1.x64/		lessons/
Material Theme/			package com.docx
Mehdi_haeri/			pdf lessons/
-----
or even:
$ ls -lF
-----
drwxr-xr-x  10 armanfeili  staff      320 Jul 12 16:28 Az payegah/
drwxr-xr-x  11 armanfeili  staff      352 Jun  3 04:25 Az system/
drwxr-xr-x   7 armanfeili  staff      224 Apr 10 15:50 Eclipse.SDK.4.7.1.x64/
drwxr-xr-x@  3 armanfeili  staff       96 May 10 01:27 Material Theme/
drwx------   4 armanfeili  staff      128 Dec 17  2017 Mehdi_haeri/
drwxr-xr-x   2 armanfeili  staff       64 Nov 25  2017 changed files/
-rw-r--r--@  1 armanfeili  staff  2331372 Jun 26  2018 data Structures Homework.zip
drwxr-xr-x   9 armanfeili  staff      288 Apr 23 12:00 eclipse-workspace/
drwxr-xr-x  16 armanfeili  staff      512 Jun 25 15:30 graphics/
-rw-r--r--   1 armanfeili  staff      423 May 20  2017 java.iml
----------------------------


* sort

ls -t       sort list by time
ls -r       to reverse the order
* ls -latr  Long listing including all files reverse sorted by time. so the most recent modified files will be shown at the bottom

ls -R       Lists files recursively => it lists all files in any directories
ls -d       List directory names, not their contents 

in order to access a file which it's name contains space, se have 2 optional ways:
1. encapsulate the entire file name in quotes
2. Use a backslash(\) to escape spaces

$ cd Elon Musk speach
-bash: cd: Elon: No such file or directory

so:
$ cd "Elon Musk speach"
or
$ cd 'Elon Musk speach'
or
$ cd Elon\ Musk\ speach/
-----------------------------------------------------------------------------

** Permissions

look at the permission below:
-rw-rw-r--

the first charactor of permission, can be:
1. -    =>  Regular file
2. d    =>  Directory
3. l    =>  Symbolic link

other charactors can be one of these symbols:
   Permission           File                                 Directory
1. r =>  Read       Allows a file to be read.           Allows file names in the directory to be read (directory content)
2. w =>  Write      Allows a file to modified           Allows entries to be modified within the directory
3. x =>  Execute    Allows the execution of a file      Allows access to contents and metadata for entries

Permission Categories:

 Symbol      Category
  u           User who owns the file
  g           Group = users who is in the files Group
  o           Other = users who are not owners or not in the group file
  a           All   = everybody

any users is in at least one group and can belong to many groups
Groups are used to organize users
the "groups" command displays a user's groups.
we can also use "id -Gn" 

[jason@linuxsvr ~]$ groups
json sales                  // the groups that we've joined into
[jason@linuxsvr ~]$ id -Gn
json sales                  // same result
[jason@linuxsvr ~]$ groups pat
pat : finance newyork       // the groups of another username
[jason@linuxsvr ~]$ groups adminuser
adminuser : adminuser       // the adminuser only is in adminuser group

------------------------------

-rw-r--r--
-(type) rw-(User) r--(Group) r--(Other or all users)

** Changing Permissions:

item        Meaning
chmod       Change mode command
ugoa        User category => user,group,other,all
+-=         Add,subtract, or set permissions
rwx         Read,Write,Execute

------------------------------
syntax is:
chom category   operator   permission
chom  u/g/o/a    +/-/=      r/w/x
------------------------------

[jason@linuxsvr ~]$ ls -l sales.data
-rw-r--r--, 1 jason jason 36 Feb 6 16:30 sales.data
[jason@linuxsvr ~]$ chmod g+w sales.data
-rw-rw-r--, 1 jason jason 36 Feb 6 16:30 sales.data
[jason@linuxsvr ~]$ chmod g-w sales.data
-rw-r--r--, 1 jason jason 36 Feb 6 16:30 sales.data
[jason@linuxsvr ~]$ chmod g+wx sales.data
-rw-rwxr--, 1 jason jason 36 Feb 6 16:30 sales.data
[jason@linuxsvr ~]$ chmod u+rwx,g-x sales.data
-rwxrw-r--, 1 jason jason 36 Feb 6 16:30 sales.data

when we use (=) it sets the permission to exaclly what we specified.

[jason@linuxsvr ~]$ chmod a=r sales.data      // it changes the permission of all users into r
-r--r--r--, 1 jason jason 36 Feb 6 16:30 sales.data
------------------------------

** Numeric based Permissions

r   w   x   
0   0   0   Value for off
1   1   1   Bunary value for on
4   2   1   Base 10 (decimal) value for on

             U       G       O
Symbolic    rwx     r-x     r--
Binary      111     101     100
Decimal      7       5       4

[jason@linuxsvr ~]$ chmod 754 

Symbolic        Octal
-rwx------      700
-rwxr-xr-x      755
-rw-rw-r--      664
-rw-rw----      660
-rw-r--r--      644
-----------------------------------------------------------------------------

Any files we create at the first stage belongs to our primary group.
in order to change the group, we use "chgrp" command
for example:

[jason@linuxsvr ~]$ ls -l sales.data
-rw-r--r--. 1 jason jason 36 Fev 6 16:30 sales.data     // we're in the jason group
[jason@linuxsvr ~]$ groups
jason sales

it shows that we're members of jason group and sales group

but any file we create will be belonged to jason group. to change the group:
[jason@linuxsvr ~]$ chgrp sales
[jason@linuxsvr ~]$ ls -l sales.data
-rw-r--r--. 1 jason sales 36 Fev 6 16:30 sales.data     // we're in the sales group

now let's change permission, so other people can edit the file.

[jason@linuxsvr ~]$ chmod g+w sales.data
[jason@linuxsvr ~]$ ls -l sales.data
-rw-rw-r--. 1 jason sales 36 Fev 6 16:30 sales.data     // we're in the sales group
-----------------------------------------------------------------------------
umask:

File creation mask determines default permissions.
if no mask were used, permissions would be:
777 for directories
666 for files

$ umask [-S] [mode]

Sets the file creation mask to mode, if given.
use -S for symbolica notation.
-----------------------------------------------------------------------------

** Find  files and directories

find coomand. syntax:
find [path...] [searchExpression]

if we don't supply any expression, it will find all files in the current directory and it's sub-directory.

-name pattern       Find files and directories that match pattern
-iname pattern      Like -name, but ignore case.(case insensetive)
-ls                 Performs an ls on each of the found items
-mtime days         Finds files that are days old
-size num           Finds file that are of size num.
-newer file         Finds files that are newer than file.
-exec command {} \; Run command against all the files that are found.
---------------------------

[jason@linuxsvr ~]$ find        // find everything

[jason@linuxsvr ~]$ find /sbon -name makedev
[jason@linuxsvr ~]$ find /sbon -iname makedev
/sbin/MAKEDEV
[jason@linuxsvr ~]$ find /bin -name *v                  // search for any files which contains 'v'
/bin/mv
/bin/env
[jason@linuxsvr ~]$ find . -mtime +10 -mtime -13        // files are more than 10 days old but less than 13 days old in the current directory.

[jason@linuxsvr ~]$ find . -size +1M                    // files that they're 1MB or grater

[jason@linuxsvr ~]$ find . -type d -newer file.txt     // find all directories that are newer than file.txt
---------------------------

** Locate

the 'locate' command is similar to 'find' but you can tell what to look for.
it returns a list of results that match the pattern.
it's faster than the find command
it queries an index, so the results are not in real time.
so if you try to look for a file which is created 2 minutes ago, you can't use 'locate'
also it is not in any System.
-----------------------------------------------------------------------------

** Display the contents of files

cat file        Display the contents of file
more file       Browse through a text file
less file       More features than more.
head file       Output the beginning(or top) portion of file    it shows just 10 lines of the file
tail file       Output the ending (or bottom) portion of file   it shows just 10 lines of the file

if you want to look at the changes a file get, cat is not a choice.
you should use tail because it's Real Time
tail -f file    Follow the file.

---------------------------
[jason@linuxsvr ~]$ cat file.txt
[jason@linuxsvr ~]$ head file.txt
[jason@linuxsvr ~]$ more file.txt
---------------------------
 
*** Nano Editor

it's an editor in terminal

[jason@linuxsvr ~]$ nano file.txt   // it show the file.txt in an internal editor
---------------------------------------------------------------------------------

*** Vi Editor

this is more powerful than nano

$ vi filename       Edit file
$ vim filename      Same as vi, but more features
$ view filename     Starts vim in read-only mode.

vi has modes for navigation:

k       Up one line
j       Down one line
h       Left one charactor
l       Right one charactor
w       Right one word
b       Left one word
^       Go to the beginning of the line
$       Go to the end of the line

esc key go back to command line

vi Insert mode
i       Insert at the cursor position
I       Insert at the beginning of th line
a       Append after the cursor position
A       Append at the end of the line.

Vi Line Mode
:w      Write (saves) the file
:w!     Forces the file to be saved
:q      Quit
:q!     Quit without saving changes
:wq!    Write and Quit
:w      Same as :wq.

:help [subcommand] Get help

/<pattern> Starts a forward search
?<pattern> Starts a reverse search

u           Undo
Command-R   Redo

changes modes:
Mode        Key
Command     Esc
Insert      i l a A 
Line        :

for copy and paste:
copy        yy
paste       p

turn on line numeric:
:set nu
---------------------------------------------------------------------------------

** Emacs Editor
powerful editor as Vi
---------------------------------------------------------------------------------

** Delete Copy Move Rename Compress files

* Remove Files

rm file             Remove file
rm -r dir           Remove the directory and it's contents recursively
rm -f file          Force removal and never prompt for confirmation.

* Copying files       
cp source_file destination_file             Copy source_file to destination_file
cp src_file1 [src_fileN ...] dest_dir       Copy source_files to destination_directory 
cp -i                                       Run in interactive mode
cp -r source_directory destination          Copy source_directory recursively to destination.

-----------------------------

[jason@linuxsvr ~]$ cp file1 file 2         // file 2 generated and it's compeletly similar to file1
[jason@linuxsvr ~]$ mkdir dir1
[jason@linuxsvr ~]$ cp file1 file2 dir      // it will copy all files into the directory
[jason@linuxsvr ~]$ ls dir
file1 file2
[jason@linuxsvr ~]$ ls dir

or even copying directories into one directory

[jason@linuxsvr ~]$ cp -r dir dir2 dir3     // copy recursively dir and dir2 into dir3
-----------------------------

* Movieng and renaming files:

mv                          Move or rename files and directories
mv source destination       Move file into destination
mv -i source destination    

-----------------------------
[jason@linuxsvr ~]$ mv dir firstDir             // dir has been renamed to firstDir
[jason@linuxsvr ~]$ mv file1 file1.renamed      // rename file1 to file1.renamed
[jason@linuxsvr ~]$ mv file1.renamed firstDir   // move ile1.renamed into firstDir
-----------------------------

* Sort Data:

sort file       Sort text in file

sort options
-k F            Soet by Key. F is the field number.
-r              Soet in reverse order
-u              Sort unique
-----------------------------

* Creating a collection of files

tar [-]   c|x|t  f  tarfile [pattern]

Create,extract or list contents of a tar archive using pattern, if supplied

tar options
c           Create a tar archive
x           Extract files from the archive
t           Display the table of contents(list)
v           Be verbose
z           Use compression
f file      Use this file

-----------------------------
[jason@linuxsvr ~]$ tar cf tps.tar tpsreports
[jason@linuxsvr ~]$ tar tf tps.tar
[jason@linuxsvr ~]$ tar xf /home/jason/tps.tar      // extract the tps.tar file
-----------------------------

* Compressing files to save Space

gzip        compress files
gunzip      Uncompress file
gzcat       Concatenates compressed files
zcat        Concatenates compressed files

* Disk Usage

du          Estimates file usage
du -k       Display sizes in Kilobytes
du -h       Display sizes in human readable format
---------------------------------------------------------------------------------

Wildcards:

a wildcard is a charactor or string that is used for match file and directory names.
we can use wildcard to create a search pattern sets and it returns a list of matching files or directories
sometimes wildcards can refer to Glob patterns, Globing is the act of expanding the wildcard into the list of matching files and directories
wildcards can be used with most linux commands. if a file eccepts a file or directory as an argument, you can use wildcard in it.
like: ls, rm, cp, ...

2 main wildcards:
* & ?

*: matches zero or more charactors (it means everything)
*.txt       // all files that has ".txt"
a*          // all files start with 'a'
a*.txt      // start with 'a' and end with '.txt'

?: matches exactly one charactor
?.txt       // one charactor and then '.txt'
a?          // all two letter files begins with 'a'
a?.txt      // two charactors and start wit 'a' and end with '.txt'
-----------------------------

we can use a charactor class to very specific search patterns
start with '[' and write any charactors we want to search for match and end with ']'.

[aeiou]     // matches any file or directory that includes any of charactors between brackets.
ca[nt]      // match files that starts with 'ca' and has 'n' or 't' in it. like: can, cat, candy, catch
[!]         // matches any of the charactors NOT included between the brackets. 
[!aeiou]*   // all files which not start with these charactors. returns: baseball, cricket

[a-g]*      // matches all files that start with a,b,c,d,e,f,g
[3-6]*      // matches all files that start with 3,4,5,6

[[:alpha:]] // matches alphabetic letters (both lower and upper case letters)
[[:alnum:]] // matches any lower or upper case alpha and digits
[[:digit:]] // numbers and decimal from 0 to 9
[[:lower:]] // any lower case letters
[[:space:]] // matches charactors like space or tab or newLine 
[[:upper:]] // uppercase letters.

\           // escape charactor
*\?         // matches all files that end with a question mark. like: 'done?'
-----------------------------

exaples:

$ ls *.txt
$ ls a*
$ ls a*.txt   ==   $ ls a*t
$ ls ?   // all files that their length is one charactor
$ ls ??  // all files that their length is two charactor
$ ls a?.txt
$ ls -l a*
$ ls c[aeiou]t  // cat, cot
$ ls [a-d]* 
$ ls *[[:digit:]]   // blues.mp3, jazz.mp3
$ mv *.txt notes    // move all text files into notes.
$ mv *.mp3 music/   // move every song into music directory
$ rm ??             // removes all files with 2 charactors
---------------------------------------------------------------------------------

** I/O
 I/O name            Abbreviation    File Descriptor
Standard Input      stdin           0
Standard Output     stdout          1
Standard Error      stderr          2

Redirection
>       Redirects standard output to a file.Overwrites(truncating) existing contents.
>>      Redirects standard output to a file. Appends to any existing contents.
<       Redirects input from a file to a command.

if you want to use file descriptor instead of file name, we should use '&'.
&       Used with redirection to signal that a file descriptor is being used.
2>&1    Combine stderr and standard output
2>file  Redirect standard error to a file

> /dev/null     Redirect output to nowhere
-----------------------------

example:

$ ls -l > files.txt         // redirect the output of 'ls -l' to a file named 'files.txt'
$ cat files.txt             // see the content of 'files.txt' and it's similar to the result of 'ls -l'
$ ls >> files.txt           // append the result to an existing file
$ sort < files.txt          // redirect the content if file into sort

$ ls -l > files.txt     == $ ls -l 1> files.txt
$ sort < files.txt > sorted_files.txt   // sort data from a file and put it into another file.

---------------------------------------------------------------------------------

** Compare the content of files

diff file1 file2        compare 2 files
sdiff file1 file2       side by side cpmarison
vimdiff file1 file2     highlight differences in vim

when we start vim, we can quit with:
Ctrl-w w        Go to next window
: q             Quit (close current window)
: qa            Quit all (close both files)
: qa!           Force quit all

---------------------------------------------------------------------------------

** Search the contents of files

grep        Display lines matching a pattern

grep searchPattern file

-i          perform a search, ignoring case
-c          Count the number of occurrences in a file
-n          precede output with line number
-v          Invert Match. Print lines that don't match

$ cat secret.txt
$ grep user secret.txt
user: jason     // find the match in lines.
$ grep o secret.txt
site: facebook.com
user: jason                 // returns the match with the charactor of 'o'
$ grep -v o secret.txt  
tags: credentials
pass: Abee!                 // returns the line with no 'o'
$ grep -i User secret.txt  
user: jason                 // -i is case insensetive
$ grep -ci User secret.txt  
1                           // case insensetive and counting numbers
$ grep -ni User secret.txt  
3:user: jason               // -n which line matches occered


** file file_name       Display the file type.

searching for Text in Binary Files:
** strings              Display printable strings

Pipe:  '|'
you can change two commands together with the pipe.
command-output  |   command-input
if first command gets standart error, the second command will return the result

for example:
grep pattern file  ==  cat file | grep pattern
the pipe gets the standard output from first command and put it into the second command as standard output.

---------------------------------------------------------------------------------

** Copying files over the Network:

SCP  - Secure copy
SFTP - SSH file transfer protocol

scp source destination   // copy source to destination
sftp host               // start a secure file transfer session with host
sftp jason@host
---------------------------------------------------------------------------------

** Customizeing the Shell Prompt:

Use an enviroment variable to customize;
- for Bash use '$PS1'

\d      Date in "Weekday Month Date" format "TueMay26"
\h      Hostname up to the first period
\H      Hostname
\n      Newline
\t      Current time in 24-hour HH:MM:SS format
\T      Current time in 12-hour HH:MM:SS format
\@      Current time in 12-hour am/pm format
\A      Current time in 24-hour HH:MM format
\u      Username of the current user
\w      current working directory
\W      basename of the current working directory
\$      if the effective UID is 0,a #, otherwise a $


---------------------------------------------------------------------------------

** Aliases:

shortcuts
use for long commands

alias [name[=value]]
List or create aliases
Use name = value to create a new alias.

it also used for fixing dictation
if you always write 'grpe' instead of 'grep',
we can make a alias for it, so if we accidently typed grpe, it would change it to grep

$ alias grpe = 'grep'

examples:

$ alias ll='ls -l'

to list aliases hust use $ alias command.

if we set some aliases and log out, and login again, aliases wuold be lost.
if you want to make it permenent, add them to you dot files: such as '.bash_profile'

$ vi ~/.bash_profile

# My aliases
alias ll = 'ls -l'
---------------------------------------------------------------------------------

** Enviroment Variable:

it is a store location that is Name/Value pair

$ printenv
HOSTNAME = web01
TERM = xterm
USER = jason
PATH = /usr/bin:/usr/sbin:/sbin:/usr/sbin
PWD = /home/jason
HOME = /home/jason

if you want to look at the value of one specific enviroment variable you can pass it's name
as an argument to the 'printenv' command
$ printenv HOME
/home/jason

Creating Enviroment Variable: syntax:
export VAR="value"

ATTENTION: don't use space around '='. if so, you get error

export EDITOR="vi"
export TZ="US/Pacific"  // set the timezone to US

---------------------------------------------------------------------------------

**  List running processes:
    Foreground vs background processes
    Launch background processes
    Kill processes

ps      Display running processes

ps options:
-e              Everything, all processes
-f              Full format listing
-u username     Display username's processes
-p pid          Display information for PID (processes identification number)

ps -e           Display all the processes
ps -ef          Display all processes full
ps -eH          Display a process tree
ps -e --forest  Display a process tree
ps -u username  Display user's processes

pstree          Display processes in a tree format
top             interactive process viewer
htop            interactive process viewer

examples:

$ ps
$ ps -p 1530
$ ps -f


*** To start a program in the background, put a '&' at the end of the command.

command &   start command in background
Ctrl-c      Kill the Foreground process
Ctrl-z      Suspend the Foreground (stop process)

bg [%num]           Background a suspended process
fg [%num]           Foreground a Background process
kill %jobNumber     Kill a process by job number or PID
jobs [%num]         List jobs  

** Killing Processes:

Ctrl-c              Kills the Foreground process
kill [-sig] pid     Send a signal to a process  (the default signal is Termination)
kill -l             Display a list of signals

kill 123
kill -15 123
kill -TERM 123
kill -9 123         -9 is the kill signal and used when -TERM doesn't work.

[jason@linuxsvr ~]$ ./long-running-program &
[1] 2373            // when a command runs in the background, 2 commands are displayed
                       the number in brackets is the job number, the second is the 'pid'

[jason@linuxsvr ~]$ ps -p 2373
or
[jason@linuxsvr ~]$ jobs %1     


current job can be refered by: %% or %+
the previous job can be refered by: %-

let's create some jobs:
[jason@linuxsvr ~]$ ./long-running-program &
[1] 2379
[jason@linuxsvr ~]$ ./long-running-program &
[2] 2381
[jason@linuxsvr ~]$ ./long-running-program &
[3] 2383
[jason@linuxsvr ~]$ ./long-running-program &
[4] 2385
[jason@linuxsvr ~]$ jobs
[1]     Running
[2]     Running
[3]     Running
[4]     Running
[jason@linuxsvr ~]$ jobs %%
[4]     Running
[jason@linuxsvr ~]$ fg %2
./long-running-program &
^c                              // killing the process number 2
[jason@linuxsvr ~]$ jobs
[1]     Running
[3]     Running
[4]     Running
[jason@linuxsvr ~]$ kill %1
[jason@linuxsvr ~]$ jobs
[3]     Running
[4]     Running
[jason@linuxsvr ~]$ kill -l     // list of all kill signals.
1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL
 5) SIGTRAP	 6) SIGABRT	 7) SIGEMT	 8) SIGFPE
 9) SIGKILL	10) SIGBUS	11) SIGSEGV	12) SIGSYS
13) SIGPIPE	14) SIGALRM	15) SIGTERM	16) SIGURG
17) SIGSTOP	18) SIGTSTP	19) SIGCONT	20) SIGCHLD
21) SIGTTIN	22) SIGTTOU	23) SIGIO	24) SIGXCPU
25) SIGXFSZ	26) SIGVTALRM	27) SIGPROF	28) SIGWINCH
29) SIGINFO	30) SIGUSR1	31) SIGUSR2
[jason@linuxsvr ~]$ jobs
[4]     Running
[jason@linuxsvr ~]$ kill -9 2385
[4]+    Killed

---------------------------------------------------------------------------------

**  Cron:

a time based job scheduling service
crontab - A program to create, read, update, and delete your job schedules
use cron to schedule and automate tasks

* * * * *
| | | | |
| | | | +----- Day of the week 0-6
| | | + ------ Month of the year 1-12
| | + -------- Day of the month 1-31
| + ---------- hour 0-23
+ ------------ minute 0-59

example:
# Run every monday at 7am
0 7 * * 1 /opt/sales/bin/weekly-report
| | | | |
| | | | +----- Day of the week 0-6
| | | + ------ Month of the year 1-12
| | + -------- Day of the month 1-31
| + ---------- hour 0-23
+ ------------ minute 0-59

crontab file    Install a new crontab from file
crontab -l      List your cron jobs
crontab -e      Edit cron jobs
crontab -r      Remove all of you cron jobs


---------------------------------------------------------------------------------

**  How to switch to another account:

su [username]   Change user ID or become superuser
su  ==  su root

-               a hyphen is used to provide an enviroment similar to what the user would expect had the user logged in directly
-c command      specify a command to be executed.

$ whoami        return account's name

** SUDO
sudo            execute a command as another user, typically the superuser

sudo -l                 List available commands
sudo command            Rund command as root
sudo -u root command    Same above
sudo -u user command    Run as user

sudo su                 Swithc to the superuser account
sudo su -               switch to the superuser account with root's enviroment
sudo su - username      switch to the username account

sudo -s                 start a shell
sudo -u root -s         same as sudo -s
sudo -u user -s         start a shell as user

use visudo to edit the sudoers file.

---------------------------------------------------------------------------------

**  Shell History and Autocompletion:

each command you enter in the shell, is recorded in shell history,shel history is stored in
memory and on disk. the path are maybe:
~/.bash_history
~/.history
~/.histfile

history         Display the shell history
HISTSIZE        Controls the number of commands to retain in history (by default it store 500 commands)

to increase HISTSIZE:
export HISTSIZE=1000

! syntax:

! N             Repeat command line number N
! !             Repeat the previous command line
! string        Repeat the most recent command starting with "string"

example:

$ head files.txt sorted_files.txt notes.txt     // we have 3 arguments
<Output from head command here>
$ !!
head files.txt sorted_files.txt notes.txt
<Output from head command here>
$ vi !:2                                        // it takes the second argument of previous command.
vi stored_files.txt
<vi editor status>

!^  =  !:1


Ctrl-r          Reverse shell history search
Ctrl-g          Cancel the search

---------------------------------------------------------------------------------

**  Packages and Package managers and how to find, install, remove software from most popular linux distribution:

a package is just a collection of files that make up an application.
the Data or Metadata has a Package description, Version, and list of Dependencies.

package managers are responsible for Install,Upgrade and Remove Packages, managing dependencies,
and keep track of what is installed

RPM Distros:        RedHat, CentOS, Fedora, Oracle Linux, Scientific Linux
yum package manager:

yum search string           Search string
yum info [package]          Display info
yum install [-y] package    Install package (use '-y', to automatically say yes to the following questions)
yum remove package          Remove package

rpm -qa                     List all installed Packages
rpm -qf /path/to/file       List the file's package

other package format:
Debian, Linux Mint, Ubuntu

Debian uses 'apt' as package manager

apt-cache search string         Search for string
apt-get install [-y] package    Install package
apt-cache show packageName      Display information about package.

dpkg -l                         List installed packages
dpkg -S /path/to/file           List file's package
dpkg -L packageName             List all files in package
dpkg -i package.deb             Install package
---------------------------------------------------------------------------------

**  Linux Boot process

BIOS stands for 'Basic Input/Output System'. it's a special firmware used in Booting process
and it's the first peice of software that runs when computer power on.
BIOS is operating system independent. it's primary purpose is test the underline hardware components and load Boot loader or Operating System
BIOS performs the POST (stands for Power-On Self Test).
the post performs some basic checks of various hardware component such as the CPU, Memory and storage devices. 
Only if the post succeed, BIOS attempt to load the boot loader.

BIOS contains a list of boot devices, such as Hard Disks, DVD drive, USB drive, etc.
The boot device search order can be changed.

Boot Loaders:
LILO        Old linux loader
GRUB        Grand Unified Boortloadr.Replaced LILO

Boot loaders start the poerating system.
Temporary filesystem that is loaded from diskl and stored in memory.

Initial RAM Disk is an temporary filesystem that is loaded from disk and stored in memory (loaded in the memory when the system boots).
Initial Ram Disk contains helpers and modules required to load the permanent OS file system.

the ./boot Directory
Contains the files required to boot Linux, initrd (initial RAM Disk), linux kernel and other boot loader configuration
the kernel is typically named vmlinuz or vmlinux

kernel Ring Buffer contains messages from the Linux Kernel.
the Ring Buffer is a data structure that is always the same size.
once the buffer is completely full, all messages be discarded when new messages arraive.
to see the content of kernel ring buffer, user 'dmesg' command.
it usually stored in /var/log/dmesg

linux uses Runlevels to determine what processes and services start.

Runlevel    Description
0           Shuts down the system
1,S,s       Single user mode. Used for maintenance
2           Multi-user mode with graphical interface (Debian/Ubuntu)
3           Multi-user text mode (RedHat/CentOS)
4           Undefined
5           Multi-user mode with graphical interface (RedHat/CentOS)
6           reboot

Systemd uses targets instead of Runlevel
to look at the targets, we look at: /lib/systemd/system

Rebooting:
3 ways:
# telinit 6
# systemctl isolate reboot.target
# reboot

PwoerOff
3 ways
# telinit 0
# systemctl isolate poweroff.target
# poweroff

------------------------------------

sometimes in order to go to the BIOS page, you should press F12 after you turned on you computer.

------------------------------------

** System logging

Linux uses the syslog standard to manage logging. that allows programs to generate messages and logs,
that can be captured process and stored by system logger.

------------------------------------------------------------------------------------

** Disk management

Disks can be divided into parts, called partitions
Partitions allow you to separate data.

MBR (Master Boot Record) is a boot sector at the begining of a boot storage device.
GUID Global Unique Identifier is a replacing for MBR partition system.

------------------------------------------------------------------------------------

** How to manage users and groups.

each user name has an id named UID.
/etc/passwd
the format of the /etc/passwd
username:password:UID:GID:comments:home_dir:shell
like =>
root:x:0:0:root:/root:/bin/bash
------------------------------------------------------------------------------------

** Networking TCP/IP:

TCP/IP: Used for network communications
TCP = Transmission Control Protocol - so two devices can exchange data
IP = Internet Protocol = is responsible for sending data from one device to another device on the network
Host = each devices on a network that have an IP address is called a Host.

peices of information:
octet.octet.octet.octet => octet values can be from 0 to 255
IP address like: 199.83.131.186
Subnet mask like: 255.255.255.0
Broadcast address: 199.83.131.255

IP address has two parts:
1. Network address => tells routers what network the host belongs to.
2. Host address => tells routers the specific device that data should be delivered to.
network and host address should be unique.

the Address Classes used to determine what portion is used for network address and what portion is used for host address


Class       Network                     Howts Allowed
A           1.0 -> 127.0                16777216
            Ex: 17.24.88.9

B           128.0 -> 191.255            65536
            Ex: 183.194.46.31       

C           192.0.0 -> 233.255.255      255  
            Ex: 199.83.131.186

Class           Network-address|Host-address
A                          255.|0.0.0
B                      255.255.|0.0
C                  255.255.255.|0


                         Net-address|Host-address
let's look at ip of:        183.194.|46.31
this is a class B ip


** A Broadcast address is a special logical address, used to send data to all host on the given network
in addition to their own ip addresses, all network host receive data sent to the broadcast address.

you can determine broadcast ip address by using the value of 255 in the octets when they are 0 in the subnet mask. 
let's look at few examples:

Class       Network         Subnet Mask         Broadcast
A           17.0.0.0        255.0.0.0           17.255.255.255
B           183.194.0.0     255.255.0.0         183.194.255.255
C           199.83.131.0    255.255.255.0       199.83.131.255

CIDR: Classless Inter-Domain Rouating:
it allows network to be sub devided regardless of their traditional class.
this sub deviding network are calles subnets.
for example the ip address of: 121.67.198.94 is in the class A network range.
By default,
the network is:   121.0.0.0
the subnet is:    255.0.0.0
the broadcast is: 121.255.255.255

however if you specify a subnet mask,you can alter the portion of ip address that is used as the network and the 
portion that is used as the host address.

so by specifying the subnet as:255.255.255.0 for ip of:121.67.198.94 
then 
the CIDR network is:   121.67.198.0
the CIDR subnet is:    255.255.255.0
the CIDR broadcast is: 121.67.198.255

there are ip addresses that is used for private network.(for company network or even home network as well)

Class   Range                         Private Address Space
A       1.0.0.0 - 127.255.255.255     10.0.0.0 - 10.255.255.255
B       128.0.0.0 - 191.255.255.255   172.16.0.0 - 172.31.255.255
C       192.0.0.0 - 233.255.255.255   192.168.0.0 - 192.168.255.255

-----------------------------------------------------------------------
to show the current ip address or all you ip addresses write 'ip address' command.
to display ip address information: '# ifconfig'

A host is a device which is connected to a network. a hostman is a human-readable name that corresponds to an IP address.
so we can use that host name instead of ip address.

DNS = Domain Name System
it's work is translate human-readable names into ip addresses.
DNS can do reverse likewise, and translate ip address to hostname

FQDN = fully qualified domain name, also contains the domain name and the top level domain name.
each section of FQDN seperated by dot(.)
like: webprod01.mycompany.com

TLD = Top Level Domain like: .com, .net, .org ,...

Domains => below (to the left of) TLD

sub-domain => like organization name, or brand name.
like: webprod01.ny.us.mycompany.com
it shows where the server is located.

to display the current hostname, write '# hostname' or '# hostname -f'

-------------------------------------

** Port : just like ip address identify host on a network, Ports identify the services on a host.
When a server starts on a system, it binds itself to a port and listens to the trafic.
Ports range are between 1 to 65535.
ports between 1 - 1023 are well-known ports. these are used for common system services

22  - SSH
25  - SMTP
80  - HTTP
143 - IMAP
389 - LDAP
443 - HTTPS

for example: when we search for a site in your web browser like: 'https://www.mybank.com'
your computer translate 'https://www.mybank.com' to an ip address. then your web browser initiates a request to that ip address
on port: 443 which specifys https protocol.
the service in this case a web server will receive the trafic on 443

the '/etc/services' file translate human readable numbers into port numbers
we can also add some ports to this list.

-------------------------------------

** DHCP : Dynamic Host Configuration Protocol
DHCP servers assign IP address to Host on a network.
when a DHCP client wants to request an IP address, it sends a broadcast massage looking for a DHCP server.
the DHCP server then responses to the client and provides it with a IP address 
and other additional information such as the net mask, the gateway, and DNS servers
the DHCP client configures itself with this information, and begins to communicate on the network.

the IP address assign to the DHCP client, is "leased" from the DHCP server
the client will be used that ip address for the leased expression time configured by DHCP server.
if the DHCP client wants to continue using the IP address beyond the leased expressoin time, it must send a newer request to the DHCP server
if the newer received by DHCP server, it will place this IP address back in the pool available addresses.
-------------------------------------

** Ping: Testing Connectivity with 'ping' command
the ping command since one or more icmp package to a host that you specify and waits for reply
to use a ping command:
# ping hostName == # ping ipAddress

by default ping will keep sending packets to stop program with Ctrl-C
if you want to specify the number of package to send, use '-c' option.

Format:
ping HOST
ping -c COUNT HOST 

example:
ping -c 3 google.com

the result will be like:
-------------------------
vps@vps:~$ ping -c 3 google.com
PING google.com (172.217.16.174) 56(84) bytes of data.
64 bytes from fra15s11-in-f174.1e100.net (172.217.16.174): icmp_seq=1 ttl=56 time=19.2 ms
64 bytes from fra15s11-in-f174.1e100.net (172.217.16.174): icmp_seq=2 ttl=56 time=9.13 ms
64 bytes from fra15s11-in-f174.1e100.net (172.217.16.174): icmp_seq=3 ttl=56 time=24.0 ms

--- google.com ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2009ms
rtt min/avg/max/mdev = 9.131/17.460/24.015/6.204 ms
-------------------------

this line of code, send 3 packets. the statistics says 3 packets received and no packet loss was encounted.
this means we had network connectivity to Google.com    
each packet has a time associated with it.
rtt stands for 'round trip time'

if there was no connectivity between the host and the website, we could see 'Unreachable' for any ping.

** The netstat Command

-n      Display numerical addresses and ports
-i      Display a list of network interfaces
-r      Display the route table. (netstat -rn)
-p      Display the PID and program used.
-l      Display listening sockets.(netstat -nlp)
-t      Limit the output to TCP. (netstat -ntlp)
-u      Limit the output to UDP. (netstat -nulp)

----------------------------------------------------------------------

** Setuid

when you start a process, it starts with running your user and group permissions (UID & GID)
setuid is an special permission = Set User ID upon execution
it enforces the process to start as the owner the file regardless of who executes that file.
to see if a file has setuid set, you can look at the 'ls -l' output.
when we see the root permissions
or in the ping command.

** Setgid
it's very much like setuid...

----------------------------------------------------------------------

** Scripts

script is a command line programe that contains series of commands.
commands contained in the script are executed by 'Interpreter'.
so an Interpreter executes commands in the script.
in the case of shell scripts, the shell access the interpreter and executes the command listed in script one after the other.
Anything you can type in the command line, you can put in a shell script.
shell scripts are graet for automating tasks.
if the script does not contain a shebang the commands are executed using your shell.

you can use variables in your shell scripts. Variables are simply sotrage locations that have a name.
they are name-value pairs. like:
VARIABLE_NAME = "value"

make sure not to use any spaces before and after the equal sign.

#!/bin/bash
MY_SHELL="bash"
echo "I like the $MY_SHELL shell."

assign a command to a variable:
SERVER_NAME=$(hostname)
or
SERVER_NAME='hostname'

example:
#!/bin/bash
MY_SHELL="bash"

-------------------------
if [ "$MY_SHELL" = "bash" ]
then
   echo "You seem to like the bash shell."
   command N
else 
   command N
fi
-------------------------

For Loop
-------------------------
for VARIABLE_NAME in ITEM_! ITEM_N
do
  command 1
  command 2
  command N
done;  
-------------------------

** Positional Parameters:

Positional Parameters are variables that contain the contents of a command line
the variables are from $0 to $9

$0:"script.sh"
$1:"parameter1"
$2:"parameter2"
$3:"parameter3"

-------------------------
the read command accepts STDIN (acceptn). the format is like:
read -p "PROMPT" VARIABLE
like:
read -p "Enter a user name: " USER
---------------------------------------------------------------------------

** Repeat as Root

we can use '!!' to repeat the previous command and maybe add sth to it.
for example we want to create a new user

$ adduser sam
-bash: /usr/sbin/adduser: Permission denied

because we should run sudu. so:
$ sudu !!
sudu adduser sam
$ id sam
uid=1007(sam) gid=1007(sam) groups=1007(sam)

-------------

To run the most recent command that begins with the given string, use '!' followed by that string
syntax: !<string>
exaples:
!d
!du
!df
-------------

If you want to use all of the arguments from your previous command, in the current command, use '!*'

example:

$ touch  file1 file2 file3
$ ls !*
ls file1 file2 file3
file1 file2 file3

or we can edit those files:
$ vi !*         // it opens the first file, when you close it, it opens the second file and continue

now we want to move them somewhere
$ mv !* /tmp/
mv file1 file2 file3 /tmp/

in order to see them:
$ ls /tmp/file*
/tmp/file1 /tmp/file2 /tmp/file3

------------------------------------------------------------------------------

Strip out comments and blank lines with the 'grep' command
'-E' to enable extended regular expressions
'v' to invert the matches => only print lines that do not matches the search pattern.
'^#^$' the '^' means the thing that starts the line.

$ grep -EV '^#^$' file.txt      // it means if the line starts with # or &, don't count it.

with this line of code, all data which is not includes comments, returns.
---------------

To use last item on the previous command line in your current command, type: '!$'

------------------------------------------------------------------------------

in order to look at ssh server process:
$ ps -ef | grep sshd

