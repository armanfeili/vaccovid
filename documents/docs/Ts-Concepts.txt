What is TypeScript?
we have JavaScript which has Constructor functions,Prototypes,Dynamic Types,...
also we have ES6
but TS has Interfaces,Strongly Typed,Generics and at the end of the day, it compiles all these new features to ES5 code.
so we can run it through browser

if we want to import a file like script.ts with .ts postfix, we should import it as script.js !
because ts compile to js

so in the command line (terminal) we can write: tsc script.ts
tsc stands for TypeScript compile , and we compile the file we wish to compile
we can use tsc because we installed TypeScript
if the code has any error, we can see them here

once we run the command correctly, we have script.js file in our folder

package lite-server is a convinent workflow to work with
also we add "start":"lite-server" to package.json, so we can run "$npm start" to start the server on "http://localhost:3001/"

instead of writing "$tsc filename" every time, we can write "$tsc --init" to create a "tsconfig.json" file,
so anytime we write just "$tsc" it compiles all TS files to JS
with command of : $tsc -w   we can turn the compiler into the watch mode, so whenever we save documents, it runs $tsc

**************************************************************************************
types in TS files can be recognized , so if we have a code like this in a JS file, there will be no error:
---------------------------------------------------------------------                              
let myName = "Max";
myName=23;
---------------------------------------------------------------------
but the code above in TS file gets error: Type '23' is not assignable to type 'string'.
thats why we say in JS we have Dynamic types and in TS we have Static types
about numbers, TypeScript doesn't differentiate between float numbers and integer numbers
like: 27 and 27.5  - and it consider both as just number

if we want to create a variable and don't assign it to anything yet, and then assign it to values,
we get no errors from TS for assigning it to string or number. because TS consider the type of this variable
as "any" by default. like:
---------------------------------------------------------------------
let myAge;
myAge = 21;
myAge = "21";
---------------------------------------------------------------------
because of the type of myAge is any, TS gets no error. but if we assign the type to myAge,then TS
gets error for assigning string to it. like:
---------------------------------------------------------------------
let myAge: any;  // by default
let myAge: number; // if we specify it.
---------------------------------------------------------------------
if we had an array of strings like bellow, we cannot add a number item to it. because at first
TS consider this array as an string array, so it doesn't let us to add a number item to it:
---------------------------------------------------------------------
let hobbies = ["cooking", "sports"];
hobbies = [100]; // gets error
---------------------------------------------------------------------
but if we specify the type of hobbies as any, or we create hobbies[] with strings and numbers at first,
we will get no error.
---------------------------------------------------------------------
let hobbies : any[] = ["cooking", "sports"]; // no error
let hobbies = ["cooking", "sports", 100]; // no error - because it consider it as any by default.
---------------------------------------------------------------------
//** tuples **//
tuples are just arrays with mixed types and limited number of items.
for example, if we have an array with just 2 items that the first item is string and the second is number,
we can specify it as bellow:
---------------------------------------------------------------------
let address : [string,number] = ["Superstreet",90];
---------------------------------------------------------------------
so address here is always has 2 items, and the first one should be string and the second one should be number
otherwise, it gets error.

//** enums **//
enum is used for creating expressive numbers. for example, we have an object of colors, and we want to
check which color has been chosen! so we create our own type by enum and name it Color, and it assigns numbers to
any color of this object. so if we have Gray,Green and Blue, the values of these colors will be 0,1,2 .
so if we create a variable and assign the Color type to it and choose a color to store in it, and then 
if we console.log() it, it shows the value of that color.
like:
---------------------------------------------------------------------
enum Color = {
    Gray,          // 0
    Green,         // 1
    Blue           // 2
}
let myColor : Color = Color.Green;
console.log(myColor); // returns 1
---------------------------------------------------------------------
sometimes we don't want the default assignment, so we can simply specify the values like this:
---------------------------------------------------------------------
enum Color = {
    Gray,          // 0
    Green = 100,   // 100
    Blue           // 101
}
let myColor1 : Color = Color.Green; // returns 100
let myColor2 : Color = Color.Blue; // returns 101
---------------------------------------------------------------------
so the values default rule is increasing 1 by 1 and it looks at the last assignment number for increasment.

// *** notice : try to avoid using type of any for variables, because it prevent you all features TS can offer you
   related to types.
   in compiled JS files we don't have these variable types anymore. 

//** types in functions **//
we can specify the type of the return value from a function. by default, the type of a function is 
based on the type of return's value.
---------------------------------------------------------------------
let myName = "Max";
let myAge = 21;

function returnMyName(){
    return myName
}
console.log(returnMyName()); // returns Max - and Max is string
---------------------------------------------------------------------
// we could do this:
---------------------------------------------------------------------
function returnMyName() : string{
    return myName
}
console.log(returnMyName()); // returns Max - No error
---------------------------------------------------------------------
function returnMyName() : string{
    return myAge
}
console.log(returnMyName()); // returns Max - error: Type 'number' is not assignable to type 'string'
---------------------------------------------------------------------
void functions => if there was nothing to get returned, we can use void type. so if we try to return something,
it gets us error.
---------------------------------------------------------------------
function sayHello() : void{
    console.log("Hi there..."); // no error
    return myName; // return error
}
---------------------------------------------------------------------
// *** argument types: we can specify the types of arguments we pass through a function.
---------------------------------------------------------------------
function multiply(value1,value2) : number {
    return value1 * value2;
}
console.log(multiply(2,"Max")); // returns NaN - with no error
---------------------------------------------------------------------
the code above gets no error, because we didn't specify the type of arguments. and it returns NaN
as (Not a Number). so if we specify types for arguments:
---------------------------------------------------------------------
function multiply(value1: number, value2: number) : number {
    return value1 * value2;
}
console.log(multiply(2,"Max")); // gets error
---------------------------------------------------------------------

//** function types **//
actually any function is a type, by it's own. imagine we have 2 functions, the first one takes 2 number arguments
and returns number, but the second one takes no arguments and is void. like:

---------------------------------------------------------------------

function multiply(value1 : number, value2: number) : number {
    return value1 * value2;
}

function sayHello() : void{
    console.log("Hi there...");
}

let myFunction ;
myFunction = sayHello();
myFunction();                  // returns Hi there...
myFunction = multiply();
console.log(myFunction(2,3));  // returns 6
---------------------------------------------------------------------
in here ,once myFunction acts as sayHello() func and then it gets call as multiply();
but if we specify the types of arguments and the type of return value, we will get error of one of these assignment.
so the syntax of specifying types for functions is like:
let myFunction : (a: type, b: type) => type ; // the types of arguments, specifies in parenthesis and
                                              // the type of return value specifies after arrow function
                                              // the names of arguments in parenthesis are not important
---------------------------------------------------------------------
let myFunction (val1: number, val2 : number) => number ; // the type of myFunction is multiply's type
myFunction = sayHello();
myFunction();                  // gets error - because it expects to receive 2 number argument and returns a number.
myFunction = multiply();
console.log(myFunction(2,3));  // returns 6
---------------------------------------------------------------------

//** Objects **//
let's suppose to have an object which ,contains 2 values, a string and a number. and we want to change the
data of that object with new data. but it gets us error:

---------------------------------------------------------------------
let userData = {
    name:"Max",
    age: 27
}
userData = {
    a: "Hello",     // gets error
    b: 22           // gets error
}
---------------------------------------------------------------------
although in changing frase we still have the same types for first and second values, but it's not
how objects work. in objects, the keys of these key-value pairs are important.so instead of using a, we should
bring the actual key (name) here.
---------------------------------------------------------------------
let userData = {
    name:"Max",
    age: 27
}
userData = {
    name: "Hello",     // now it works
    age: 22           // now it works
}
---------------------------------------------------------------------
or we can specify the types of userData object, so it can be more certain.
the syntax is like this:
let myObject : { key1:string , key2:number} = {   // we use brackets for specifying types of key-value pairs
    key1 : "Hello",
    key2 : 22
}
so we will have:
---------------------------------------------------------------------
let userData : { name: string, age: number} = {
    name:"Max",
    age: 27
}
userData = {
    name: "Hello",     // now it works
    age: 22           // now it works
}
---------------------------------------------------------------------
lets see more complex object
---------------------------------------------------------------------
let complex: { data: number[]; output: (all: boolean) => number[] } = {
  data: [20, 39.02, 100],
  output: function(all: boolean): number[] {
    return this.data;
  }
};
---------------------------------------------------------------------
it's an object with 2 key-value pairs, the first one's value is array of numbers, the second one is a function

//** types alias **//
sometimes complex types can be a pain in neck and if we have several variables,functions,objects,ets...
we can create a type and name it and always use this type for variables which has the same types. like:
the syntax of building a type can be possible with the type keyword.
---------------------------------------------------------------------
type Complex = { data: number[]; output: (all: boolean) => number[] };

let complex: Complex = {
  data: [20, 39.02, 100],
  output: function(all: boolean): number[] {
    return this.data;
  }
};
---------------------------------------------------------------------
so anytime we want to add type, we add Complex to the objects which have same type mode.

//** union types **//
sometimes you know the type you wanna use is either string or number and certainly it won't be boolean, so you can use type of any,
or a better solution is using unions. the syntax is :
let variable : type1 | type2 ;
in here, myRealAge will be either 27 or "27", so using of unions, we have:
---------------------------------------------------------------------
let myRealAge : string | number = 27;    // no error
myRealAge = "27";                        // no error
myRealAge = true;                        // gets error
---------------------------------------------------------------------
//** checking types **//
with the keyword of typeof , we can see what the type is?, and for checking that, we should bring the types between qoutation marks
the syntax is like this:
---------------------------------------------------------------------
let finalValue = "this is a string";
if(typeof finalValue == "string"){             // checking string
    console.log("the type was string");
} else if(typeof finalValue == "number"){      // checking number
    console.log("the type was number");
}
---------------------------------------------------------------------
//** never type **//
sometimes you know that your function will never return anything. so when we know that this function should not be reached or it should 
never gets called, and for making your intention clear, you can use never, instead of void.
---------------------------------------------------------------------
function neverReturns() : never {
    throw new Error("An error!");           //this error should never show up.
}
---------------------------------------------------------------------
//** Nullable types **//
sometimes for clearing the value of a variable, we assign null to that. but it can lead us to some errors and problems.
so if we add a rule for TS compiler in tsconfig.json , "strictNullChecks": true , anytime we assign null to a variable
with type of number, it gets us an error : Type 'null' is not assignable to type 'number'.
by default, "strictNullChecks" sets as false. and it doesn't get us error. with turning it into true, now we can make sure
that it avoid us from assigning null accidentally to a variable which should just takes numbers.
---------------------------------------------------------------------
// with "strictNullChecks": true

let cantBeNull = 12;                        // no error    // the value is 12 and the type is number
cantBeNull = null;                          // gets error  // the value is cleard and now is null and the type is number and can't be null
                                                           
let canAlsoBeNull;                                         // the value is undefined by default and the type is any
canAlsoBeNull = null                        // no error    // the value is null and the type is null - browser knows the type as object

let canBeNull : number | null = 12;         // a Nullable variable  // using unions
canBeNull = null;                           // no error 


// with "strictNullChecks": false

let canBeNull = null;
console.log(typeof canBeNull);              // no error    // returns object - 
canBeNull = 12;
console.log(typeof canBeNull);              // no error    // returns number
---------------------------------------------------------------------
another example:

function contorlMe (isTrue : boolean) {
    let result : number;
    if(isTrue){
        result = 12;
    }
    return result;
}
---------------------------------------------------------------------
here if we set "strictNullChecks" to true, we get error. because now compiler figure out that isTrue might be false.
so if it is false, result will never be assigned, so the error will be like:
error TS2454: Variable 'result' is used before being assigned.
---------------------------------------------------------------------
//** how TS compiler works? **//

let's say we have this code in TS file:

let myName : string = "Max";
myName = 23;                                // gets error in TS compiler

but even though we get error in ts compiler, ts will compile all the code into the app.js file. so in app.js we have:

var myName2 = "Max";
myName2 = 23;

so actually TS compiler, give us this chance to fix the problem, although TS compiles it anyway.
but in tsconfig.json file, we can configer how the compiler should behave!

in tsconfig.json file we have options named compilerOptions which includes
"module": "commonjs"        // ts compiler compiles in common JS format
"target" : "es5"            // targrt is es5 by default
"noEmitOnError": true       // it avoid compiler to compile TS with errors into JS
                            // it doesn't emit the js file if we have error in ts file
                            // the default is false

"sourceMap": true           // if we set "sourceMap" to true, in addition to app.js file, app.js.map file also will be created
                            // so we can access the app.ts file in developer tools of browser, in Source tab
                            // so we can set a break-point in app.ts file in developer tools and execute code till the certain point
                            // so we can debug ts code directly in the browser

"noImplicitAny": true       // it prevent us to define a variable with no type,
                            // so ts will not assign any to an undefined variable and if we also don't assign any or other types to a variable, it gets error
                            // the default is false

"noUnusedParameters": true  // it gets error if we define a parameter in a function and never use that.
                            // 'otherParameter' is declared but its value is never read.

---------------------------------------------------------------------
with command of : $tsc -w   we can turn the compiler into the watch mode, so whenever we save documents, it runs $tsc

---------------------------------------------------------------------
//** ES6 tips **//

arrow functions in TS:
---------------------------------------------------------------------
const countDown = (start: number = 10): void => {
    while(start > 0){
        start--;
    }
    console.log("Done!", start);
};
countDown();
---------------------------------------------------------------------
countDown is an arrow function which takes 1 parameter that by default it's value is 10. and this arrow function
returns void.
notice that in specifying parameters, priaroty is really important.
---------------------------------------------------------------------
const countDown = (start: number = 10, end :number = start - 10): void => {         // no error
    // code
};

const countDown = ( end :number = start - 10, start: number = 10): void => {         // error on first "start" - because we didn't define start
    // code
};
---------------------------------------------------------------------
//** Rest and Spread **//
sometimes we want to spread an array into single variables. so we use ...arrayName
---------------------------------------------------------------------
const numbers = [10,20,99,-5];          // array of numbers
console.log(Math.max(3,42,99,152));     // no error - it takes a list of numbers
console.log(Math.max(numbers));         // it gets error, because Math.max() takes list of numbers, not array of numbers
console.log(Math.max(...numbers));      // no error - because it takes individual numbers as list of numbers
---------------------------------------------------------------------
when we want to take some values and put them into an array, we use rest parameters:
---------------------------------------------------------------------
const makeArray = (...args : number[]) => {
    return args;        
}
console.log(makeArray(1,2,6));          // takes single values - returns [1,2,6]
---------------------------------------------------------------------
const makeArray = (name: string, ...args : number[]) => {
    return args;        
}
console.log(makeArray("Max", 1,2,6));   // it takes "Max" first, and then it takes some numbers and put them in an array as rest parameter
---------------------------------------------------------------------
// ** Destructuring ** //
Destructuring arrays:
---------------------------------------------------------------------
const myHobbies = ["cooking","sports"]; // an array of strings
const [hobby1,hobby2] = myHobbies;      // variables hobby1 and hobby2 take the first and second value of myHobbies array
console.log(hobby1,hobby2);             // returns cooking sports
---------------------------------------------------------------------
Destructuring objects:
---------------------------------------------------------------------
the order does matter!!
const userData = {userName:"Max" , age:27};
const {userName,age} = userData;                    // we should use the same name as the object.
console.log(userName, age);                         // returns Max 27
const {userName: myName, age: myAge} = userData;    // if we want to use other name, we should define them after colon
console.log(myName, myAge);                         // returns Max 27
---------------------------------------------------------------------
// ** Classes ** //
classes in TS are different from JS, in TS we define variables directly right in the own class body, and we don't have to 
define them in the Constructor, so we won't need the "this" keyword. so we can use prefixes like "public" or "private"
or "protected" for variables like any other languages. when we set public, the property will be avalable
for wherever wnats to access it. but we can leave it out, because the default is public. So by default variables will accessable
from outside.
if we set "private", we can access the property only from inside of this class and later within any objects we create base of this class.
sometimes we can use "protected", protected properties also can be accessable from objects we create base on this class, and additionally, will be 
accessable from any classes or objects which inherit this class.

nevertheless, we can also define constructor for the class which may takes some arguments
---------------------------------------------------------------------
class Person {
    name: string;             // equals to:  public name: string;
    private type: string;
    protected age : number;

    constructor(name: string){
        this.name = name;
    }
}
---------------------------------------------------------------------
there is a shortcut that TS offers us, for setting out properties which also we want to set in our constructor.
for example:
---------------------------------------------------------------------
class Person {

    constructor(public username: string){
        
    }
}
*********
the code above equals to code bellow:
*********
class Person {
    public username: string;

    constructor(username: string){
        this.username = username;
    }
}
---------------------------------------------------------------------
with the "public" keyword, we're telling TS not only expect to get the username as argument in the constructor function, 
but also automatically, create a public pop property in this Person class (and it could be private or protected too),
and assign the argument you get passed into constructor to username property

so it's a shortcut for creating a property in class,getting the argument,and then assigning the argument.
---------------------------------------------------------------------
class Person {
    name: string;             // equals to:  public name: string;
    private type: string;
    protected age : number;

    constructor(name: string , public username: string){
        this.name = name;
    }
}

const person = new Person("Max", "max123");
console.log(person);                                // returns: Person {username: "max123", name: "Max"}
console.log(person.name, person.username);          // returns: "max123","Max"
console.log(person.type, person.age);               // error: type and age are private and protected and can't be accessable from outside
---------------------------------------------------------------------
*** we can define methods in the class to use those private and protected properties. ***
---------------------------------------------------------------------
class Person {
    name: string;             // equals to:  public name: string;
    private type: string;  
    protected age : number = 27;

    constructor(name: string , public username: string){
        this.name = name;
    }

    printAge(){
        console.log(this.age);
    }

    setType(type: string){
        this.type = type;
        console.log(this.type);
    }
}

const person = new Person("Max", "max123");
person.printAge();              // returns 27
person.setType("Cool guy");     // returns Cool guy
---------------------------------------------------------------------
functions in classes can also be private or protected
---------------------------------------------------------------------
class Person {
    name: string;             // equals to:  public name: string;
    private type: string;
    protected age : number = 27;

    constructor(name: string , public username: string){
        this.name = name;
    }

    printAge(){
        console.log(this.age);
        this.setType("old guy")
    }

    private setType(type: string){
        this.type = type;
        console.log(this.type);
    }
}

const person = new Person("Max", "max123");
person.printAge();              // returns 27 and old guy
person.setType("Cool guy");     // error - won't work!!!
---------------------------------------------------------------------
// ** Inheritance in Classes ** //
we can for example create a specific Max class which inherit Person class. in Max class, we want all
properties and functions we have in Person class, but we just want the name to have the value of "Max" 
by default.
so we extend the Person class into Max class with "extends" keyword. so it takes whole Person class and any code we write in Max class,
will be appended if it wasn't included in this class or overwritten if it was included. so we can say:
---------------------------------------------------------------------
class Max extends Person{
    name = "MAX";                        // name will be overwritten
}
const max = new Max("Anna","max123");    // it still wants 2 arguments for it's constructor.
console.log(max);                        // returns: Max {username: "max123", age: 27, name: "MAX"}
---------------------------------------------------------------------
as you see, passing "Anna" will have no affect on result and still Max will be prtinted.

you can also write Max's own constructor to overwrite the old constructor.
*** when extending a class, we should always use the super() at the constructor, super() refers to the parent class and it 
calls the constructor of parent class
---------------------------------------------------------------------
class Max extends Person{
    constructor(username: string){
        super("Max",username)            // here we should pass the name we want the "name" property to have, and 
                                         // pass the username to sit as "username" property.
    }
}
const max = new Max("max123");           // we just have to pass the username, and we don't need to pass the name.
console.log(max);                        // returns: Max {username: "max123", age: 27, name: "MAX"}
---------------------------------------------------------------------
now we want to change "age"! "age" was protected, so we can access it through the Max, but we can never access the "type"
because "type" was private 
---------------------------------------------------------------------
class Max extends Person{
    constructor(username: string){
        super("Max",username)            
        this.age = 31;
    }
}
const max = new Max("max123");           
console.log(max);                        // returns: Max {username: "max123", age: 31, name: "MAX"}
---------------------------------------------------------------------
so in inheriting, we can access to everything except private properties.
---------------------------------------------------------------------
// ** Setter and Getter  ** //
// ** assigning and returning private values with Setter and Getter ** //

whenever we had private property , we can access it with setter and getter.
for example, we have a normal class named "Planet" which has a private property named "_species".
now we want to check if the _species is longer than 3 charactors or not, if it was, we assign a value to it.
so we can use "set" and "get" keyword to assign and return values.
*** we bring parenthesis after variables but we don't call them like a function outside of the class.***
we call them like a property. but we write the variable like a function
in "get" brackets, we should return sth, it can be it's own value, or it can returns "Hello!".
---------------------------------------------------------------------
class Planet{
    private _species: string = "default";
    
    get species(){
        return this._species;
    }

    set species(value: string){
        if(value.length > 3){
            this._species = value;
        }else{
            this._species = "default";
        }
    }
}

let planet = new Planet();
console.log(planet.species);        // returns:  default
planet.species = "AB"
console.log(planet.species);        // returns:  default
planet.species = "Green Planet"
console.log(planet.species);        // returns:  Green Planet
---------------------------------------------------------------------
so the private variable here was "_species" , but we used get and set on properties named "species".
so the word "species" is the word which can be accessed from outside of the class. and we call that like
a property not a function.
---------------------------------------------------------------------
// ** Static properties and methods ** //   ********************* IMP
we can use static keyword for accessing properties in classes, even without creating instances from that class.
---------------------------------------------------------------------
class Helper{
    static PI: number = 3.14;
    static calcCircumference(diameter: number): number{
        return this.PI * diameter;
    }
}

console.log(Helper.PI);                         // returns 3.14    --   it could have not work if we didn't use static keyword
                                                // because we didn't create an instance from Helper class. but with static keyword we can
                                                // access PI from everywhere by calling it like a property of an object -> Helper.PI
console.log(Helper.calcCircumference(8));       // returns 25.12
---------------------------------------------------------------------
// ** Abstract classes and abstract methods ** //
Abstract classes are classes which cannot be instantiate directly. they are exist just to inherit them.
so these classes don't need to instantiate (create instance form ),maybe because of they have basic setups ,which specialize classes need!

for abstract functions, we just need them to specify how the method's type should looks like!
(with specifying arguments type and return type), but we don't implement any logic
---------------------------------------------------------------------
abstract class Project{
    projectName: string = "Default";
    budget: number;

    abstract changeName( name: string ): void;      // it shows just how changeName() should looks like.
                                                    // with make this method abstract, we are required to overwrite it in the inherited class.
                                                    // so we need to implement changeName()

    calcBudget(){                                   // here , changeName() *should* be overwritten, but calcBudget() doesn't need to be overwritten.
        return this.budget;
    }
}

class ITProject extends Project {
    changeName( name: string ): void => {
        this.projectName = name;
    }
}

let newProject = new ITProject();
console.log(newProject);
ITProject.changeName("Super it project");
console.log(newProject);
---------------------------------------------------------------------
// ** Private constructor ** //
sometimes we can use private constructor or private static variables, when we want to create the instance just once.
---------------------------------------------------------------------
class onlyOne{
    private static instance: onlyOne;

    private constructor(public name: string){};                 // we used (public name: string) so we actually created name property
                                                                // and assigned name to this.name.
    static getInstance(){       
        if(!onlyOne.instance){                                  // check if we already have such a instance or not
            onlyOne.instance = new onlyOne('The Only One');
        }
        return onlyOne.instance;
    }
}

let wrong = new onlyOne('The Only One');        // gets error  ->  Constructor of class 'onlyOne' is private and only accessible within the class declaration.
let right = onlyOne.getInstance();              // works just once.
---------------------------------------------------------------------
// ** Read Only ** //
we can use readonly to make variables accessable from outside the class, but not be able to change it from outside.
---------------------------------------------------------------------
class onlyOne{
    private static instance: onlyOne;
    public readonly name: string;                               // make this property just readonly

    private constructor(name: string){
        this.name = name;
    };

    static getInstance(){       
        if(!onlyOne.instance){                                  // check if we already have such a instance or not
            onlyOne.instance = new onlyOne('The Only One');
        }
        return onlyOne.instance;
    }
}

let right = onlyOne.getInstance();              // works just once.
right.name = "something else";                  // Cannot assign to 'name' because it is a read-only property.
---------------------------------------------------------------------
*** More examples ***
EX1:

abstract class baseObject {
  protected width: number;
  protected length: number;

  constructor(width: number, length: number) {
    this.width = width;
    this.length = length;
  }
}

class Rectangle extends baseObject {
  constructor(width: number, length: number) {
    super(width, length);
  }

  calcSize(): number {
    return this.width * this.length;
  }
}

let rectangle = new Rectangle(5, 2);
console.log(rectangle.calcSize());          // returns 10

---------------------------------------------------------------------

EX2:

class Person {
  private _firstname: string = "";
  get firstName() {
    return this._firstname;
  }
  set firstName(value: string) {
    if (value.length > 2) {
      this._firstname = value;
    } else {
      this._firstname = "";
    }
  }
}

let person = new Person();
console.log(person.firstName);          // returns  ""
person.firstName = "AF";
console.log(person.firstName);          // returns  ""
person.firstName = "Arman";
console.log(person.firstName);          // returns  "Arman"
---------------------------------------------------------------------
// ** Namespaces ** //
sometimes we can use namespace keyword to build multiple workspaces in a file rather than having all the code
in the state of global brace. so we can create a namespace just like a class, and wirte all the code (including
defining variables and functions or objects and so on...)
in order to access the variables or functions from outside of namespaces, we should export them from namespace.
---------------------------------------------------------------------
namespace MyMath {
  const PI = 3.14;

  function calculateCircumference(diameter : number) {                      // we can't access it from outside
    return diameter * PI;
  } 
  export function calculateRectangle(width : number, heigth: number) {      // we can access it from outside
    return width * heigth;
  } 
}

const PI = 2.63;

console.log(MyMath.calculateCircumference(5));    // returns error, because calculateCircumference() wasn't exported
console.log(MyMath.calculateRectangle(10,20));    // works and returns 200
console.log(PI);                                  // works and returns 2.63
---------------------------------------------------------------------
imagine we had a lot of functions for doing mathematics on circle and a lot of functions for doing mathematics for rectangles
so the better way of using them is, creating separate files, name 'rectangleMath.ts' and 'circleMath.ts' ,
so in rectangleMath.ts we have:
---------------------------------------------------------------------
namespace MyMath {
    export function calculateRectangle(width: number, heigth: number) {
        return width * heigth;
    }
}
---------------------------------------------------------------------
and in circleMath.ts we have:
---------------------------------------------------------------------
namespace MyMath {
    const PI = 3.14;

    export function calculateCircumference(diameter: number) {
        return diameter * 2;
    }
    
}
---------------------------------------------------------------------
and in app.ts we have:
---------------------------------------------------------------------
const PI = 2.63;

console.log(MyMath.calculateCircumference(5));
console.log(MyMath.calculateRectangle(10, 20));
console.log(PI); // returns 2.63
---------------------------------------------------------------------
but it doesn't work, because we didn't import MyMath namesoace from those files.
one solution is importing all those files in 'index.html' file.
the better solution is combine all those files into one separate single file, by command of bellow:
---------------------------------------------------------------------
$ tsc --outFile app.js rectangleMath.ts circleMath.ts app.ts
---------------------------------------------------------------------
tsc, calls the TypeScript compiler, --outFile, creates one single file, then we specify the file name we want to create
like app.js (because this is the file we imported to 'index.html'), and then  we bring all the files we want to bundle
into app.js file. (the order here,could be important because maybe you prefer one file to be executed first)
files to combine are: rectangleMath.ts, circleMath.ts, app.ts
now if we look at the source of browser, we can see all the code have combined together into the app.js

but still, if we had a lot of files to combine, we should bring them all in the command line,
a better way of combining them is bringing them directly into the app.ts file, and then create a single file from
app.ts

*****
the syntax of importing namespaces are a little different from normal importing. and is like:
/// <reference path="filename.ts">
so it starts with 3 slashes /// and then like an HTML tag, we have reference and the path attribute
---------------------------------------------------------------------
/// <reference path="circleMath.ts">
/// <reference path="rectangleMath.ts">

const PI = 2.63;

console.log(MyMath.calculateCircumference(5));    
console.log(MyMath.calculateRectangle(10, 20)); 
console.log(PI); // returns 2.63
---------------------------------------------------------------------
and then we should use this command to combine app.ts into app.js
---------------------------------------------------------------------
$ tsc app.ts --outFile app.js
---------------------------------------------------------------------

we also can have namespaces in namespaces, but we should export internal namespaces in order to access them.
---------------------------------------------------------------------
namespace MyMath {
    export namespace Circle{
        const PI = 3.14;

        export function calculateCircumference(diameter: number) {
            return diameter * 2;
        }
    }
}
------------------------
and in app.ts we have:
------------------------
/// <reference path="circleMath.ts">

console.log(MyMath.Circle.calculateCircumference(5));   
---------------------------------------------------------------------
so we used 'MyMath.Circle' to access the namesoace.
we could use a variable instead of whole name above: the syntax comes with 'import'
---------------------------------------------------------------------
/// <reference path="circleMath.ts">

import CircleMath = MyMath.Circle;

console.log(CircleMath.calculateCircumference(5));   
---------------------------------------------------------------------

// ** Modules ** //
we use namespaces for small applications, but for larger applications, we can use modules. so instead of using
namespaces, we can create separate files and export anything we want from those files.
let's say we have folder name math, and we have 2 files with names of: circle.ts and rectangle.ts
in circle.ts we have:
---------------------------------------------------------------------
export const PI = 3.14;

export function calculateCircumference(diameter: number) {
    return diameter * PI;
}
---------------------------------------------------------------------
and in app.ts file, we have:
---------------------------------------------------------------------
import {PI, calculateCircumference} from './math/circle.ts';

console.log(PI);
console.log(calculateCircumference(5));         // Uncaught ReferenceError: require is not defined
---------------------------------------------------------------------
so, it gets us error, because we need a module loader inorder to run the code above correctly.
one popular module loader is SystemJS, an universal dynamic module loader - loads ES6 modules,AMD,CommonJS and
global scripts in the browser and NodeJS. so it's an external npm module:
$ npm i systemjs@0.19.36 --save      => this is an old version, but it works.
after installing that, we go to 'index.html' file, and instead of <script src="app.js"></script>
we will have: ***
---------------------------------------------------------------------
<script src-"node_modules/systemjs/dist/system.js"></script>
<script>
      // set our baseURL reference path
      SystemJS.config({
        baseURL: "/",
        packages: {
          "/": {
            defaultExtension: "js"
          }
        }
      });

      // loads /app.js
      SystemJS.import("app.js");
</script>
---------------------------------------------------------------------
with code above, now we can import and export files in app.ts
*****
but it's almost deprecated and nowadays they use webpack and bundle.js
---------------------------------------------------------------------
<script src="dist/bundle.js"></script>
---------------------------------------------------------------------
we can also use "* as Circle" in order to import everything from a file, and name it as Circle, so we can access
all with Circle prefix.
also if we define a function as default export, then we don't need to wirte it's actual name for importing.
we can call it whatever we want while importing it. like:
import calc from "./math/rectangle";
and 'calc' will work.
---------------------------------------------------------------------
import * as Circle from "./math/circl";
import calc from "./math/rectangle";

console.log(Circle.PI);
console.log(Circle.calculateCircumference(5)); // Uncaught ReferenceError: require is not defined
console.log(calc(2, 5));
---------------------------------------------------------------------
*** Interfaces ***

look at the code bellow:
---------------------------------------------------------------------
function greet(person: {name: string}) {
  console.log("Hello " + person.name);
}

const person = {
  name: "Max",
  age: 27
};

greet(person);          // returns -> Hello Max
---------------------------------------------------------------------
here we have a greet function which takes a person object that contains a "name" key.so person type is object.
what if name property in person object was not exist:
---------------------------------------------------------------------
function greet(person: {name: string}) {
  console.log("Hello " + person.name);
}

const person = {
  firstName: "Max",
  age: 27
};

greet(person);          // returns -> Hello undefined
---------------------------------------------------------------------
so it doesn't give us an error, but it returns undefined. now if we had 2 or more functions, we should always change the type
of properties of object as the way they are in the object.
---------------------------------------------------------------------
function greet(person: {firstName: string}) {
  console.log("Hello " + person.firstName);
}

function changeName(person : {firstName: string}){
  person.firstName = "Anna";
}

const person = {
  firstName: "Max",
  age: 27
};

greet(person);          // returns -> Hello Max
changeName(person);
greet(person);          // returns -> Hello Anna
---------------------------------------------------------------------
so, we could create an interface in order to change a property names and types in one place:
---------------------------------------------------------------------
interface NamedPerson {
    firstName: string;
}

function greet(person: NamedPerson) {
  console.log("Hello " + person.firstName);
}

function changeName(person : NamedPerson){
  person.firstName = "Anna";
}

const person = {
  firstName: "Max",
  age: 27
};

greet(person);          // returns -> Hello Max
changeName(person);
greet(person);          // returns -> Hello Anna
---------------------------------------------------------------------
now if we change the object, we should change just interface, then code will work.

if we pass an object directly into a function with interface requirement, and not pass it as constant object,
we may face some error, because it also check for everything we passed with all elements in interface:
---------------------------------------------------------------------
interface NamedPerson {
    firstName: string;
}

function greet(person: NamedPerson) {
  console.log("Hello " + person.firstName);
}

const person = {
  firstName: "Max",
  age: 27
};

greet({firstName: "Max", age:27});          // error -> 'age' does not exist in type 'NamedPerson'.
---------------------------------------------------------------------
so we can specify age in the interface and also we can make it optional by this syntax:
age?: number;
---------------------------------------------------------------------
interface NamedPerson {
    firstName: string;
    age?: number;
}

function greet(person: NamedPerson) {
  console.log("Hello " + person.firstName);
}

const person = {
  firstName: "Max",
  age: 27
};

greet({firstName: "Max", age:27});          // returns -> Hello Max
---------------------------------------------------------------------
also if we knew we could have a property in the object we wanna pass to the function, and didn't know what the name of that
or what the kind of that property is, we can specify that property with this syntax:
[propName: string]: any;
here, we can specify any name for that property we forgot the name of (here we used "propName"), then we specified the probable type
of that property (here is "string"), these [,] are not soppose to have the meaning of array! then we can specify "any" type for not having
any error.
---------------------------------------------------------------------
interface NamedPerson {
    firstName: string;
    age?: number;
    [propName:string]:any;
}

function greet(person: NamedPerson) {
  console.log("Hello " + person.firstName);     // returns -> Hello Max
  console.log("Hobbies " + person.hobbies[0]);  // returns -> Hobbies cooking
}

const person = {
  firstName: "Max",
  age: 27,
  hobbies: ["cooking","sports"]
};

greet(person);          // no error
---------------------------------------------------------------------
hobbies here, doesn't have to be array, it could be anything with any type. but the code still works.
interfaces can also contain methods in theirselves, so if the object had a method in itself, interface also should have the method.
so the person object also should have the type of NamedPerson,
---------------------------------------------------------------------

interface NamedPerson {
  firstName: string;
  age?: number;
  [propName: string]: any;
  greet(lastName: string): void;
}

function greet(person: NamedPerson) {
  console.log("Hello " + person.firstName); // returns -> Hello Max
  console.log("Hobbies " + person.hobbies[0]); // returns -> Hobbies cooking
}

const person: NamedPerson = {
  firstName: "Max",
  age: 27,
  hobbies: ["cooking", "sports"],
  greet(lastName: string) {
    console.log("Hi I'm " + this.firstName + " " + lastName); // returns -> Hi I'm Max Anything
  }
};

greet(person); //  no error
person.greet("Anything"); //  returns -> Hi I'm Max Anything

---------------------------------------------------------------------
*****
we can also implement interfaces into classes: "implements" keyword is really important here.
---------------------------------------------------------------------

interface NamedPerson {
  firstName: string;
  age?: number;
  [propName: string]: any;
  greet(lastName: string): void;
}

class Person implements NamedPerson{
    firstName: string;
    greet(lastName: string) {
        console.log("Hi I'm " + this.firstName + " " + lastName); // returns -> Hi I'm Max Anything
    }
}

const myPerson = new Person();
myPerson.firstName = "Max"
myPerson.greet("Anything");         // Hi I'm Max Anything
---------------------------------------------------------------------
so interfaces are contracts which can be signed and which can be used as a type and which can make sure all these conditions set up in 
the interface (the require ones and the optional ones) have to be full filled by whatever which has the interface type.
it can be an object with interface type, or it can be a function with that interface type or
it can be a class which implements the interface.

it can also be a function-type :  so whatever uses this interface should be a function with this type of arguments and return type.
---------------------------------------------------------------------
interface DoubleValueFunc {
    (number1: number, number2: number): number;
}

let myDoubleFunction: DoubleValueFunc;
myDoubleFunction = function(value1: number, value2: number){
    return (value1+value2) * 2;
}
console.log(myDoubleFunction(20,10));   // 60
---------------------------------------------------------------------
*Interface Inheritance*
we can inherit interfaces by using extends keyword.
---------------------------------------------------------------------
interface AgedPerson extends NamedPerson {
    age: number;        // age was optional in NamedPerson, but here it is required
}

const oldPerson: AgedPerson ={      // oldPerson should have both NamedPerson and AgedPerson requirements.
    age:27, 
    firstName="Max",
    greet(lastName: string){
        console.log("Hello!");
    }
}

console.log(oldPerson);
---------------------------------------------------------------------
interfaces do not get compiled to JavaScript.they are there to get error of type compiling through transforming to JS. JavaScript
doesn't know types, so it doesn't know interfaces neither.
---------------------------------------------------------------------

// *** Generics *** //
with generics, we can specify the types of arguments a function can take, so TS can undrestand what the type is and can offer us
suitable suggestions for that specific type.
---------------------------------------------------------------------
function echo (data: any){
    return data;
}

console.log(echo("Max").length);                    // returns 3
console.log(echo(27).length);                       // returns undefined
console.log(echo({name: "Max", age: 27}).length);   // returns undefined
---------------------------------------------------------------------
here we have somehow a generic function, because it can handle all kinds of data. but it could be better if TS was aware about the 
exact data type of any.
the code above returns undefined for using ".length" for number and object. but TS doesn't give us any error while compilation.

for craeting generics, we use this following syntax:
we use any charactor in a tag (like: <T>) after the name of the function. this tag, makes a generic function,and tells TS it's an generic function.
so this "T", tells the TS: when using this function, give me the type, and I will be able to use this type. therefore, we can use the
"T" as a type.
* notice: instead of T, we can use any charactor, but T is more common.
---------------------------------------------------------------------
function betterEcho<T>(data: T){
    return data;
}

console.log(betterEcho("Max").length);                    // returns 3
console.log(betterEcho(27).length);                       // gets error
console.log(betterEcho({name: "Max", age: 27}).length);   // gets error
---------------------------------------------------------------------
actually, here TS knows what the type is, so by using ".length" for number or object, it give us error and prevent us from getting undefined in the console.

by the way, we can also explicitly say what type of argument, we wanna pass through this function with syntax of <number> or <string>
after function name while we're calling it.
---------------------------------------------------------------------
console.log(betterEcho<number>(27));        // works
console.log(betterEcho<string>(27));        // gets error - because the argument should be number.
---------------------------------------------------------------------
/* Built-in generics */
Arrays are generic type by default. but we can specify what the type they're gonna take for their values.
---------------------------------------------------------------------
const testResult: Array<number> = [1.54,2.63];      // this array should only take numbers
testResult.push(-2.44);             // wroks fine
testResult.push("string");          // gets error
---------------------------------------------------------------------
// Generic Array:

function printAll<T>(args: T[]){        // it knows it's gonna take an array of just one type, becasue it's a generic function
    args.forEach(elemetn => console.log(element));      
}
printAll<string>(["Apple","Banana"]);       // it takes an array which all elements are string
---------------------------------------------------------------------
/* Generic types*/
since here, we had generic functions, but we also can have generic types
look at the code bellow:
---------------------------------------------------------------------
function betterEcho<T>(data: T) { 
  return data;
}

const echo2: <T>(data: T) => T = betterEcho;

console.log(echo2("Something")); // Something
---------------------------------------------------------------------
so we used this syntax to create a generic type named "echo2".
at first we declared a constant of echo2, then anything between ":" & "=" is the type assignment. then we assigned this type to a
function which is betterEcho here. in the type assignment part,<T> is the generic syntax and then we have a function type.
so echo2 will hold a function, where the input is "data" as one argument of type "T",and it return sth with "T" type
---------------------------------------------------------------------
/* Generic classes */

class SimpleMath<T>{
    baseValue: T;
    multiplyValue: T;
    calculate(): number{
        return +this.baseValue * +this.multiplyValue;       // becasue TS knows baseValue still can be sth like string instead of number
                                                            // we should add a "+" before "this.baseValue" and "this.multiplyValue", in 
                                                            // order to make it work. so it add the previus value to the current value.
    }
}

const simpleMath = new SimpleMath();
simpleMath.baseValue = 10;
simpleMath.multiplyValue = 20;
console.log(simpleMath.calculate());        // 200
---------------------------------------------------------------------
now if we pass "something" as "baseValue", it doesn't give us error, but it show us NaN in the console.
we can do this to make it more certain:
with keyword of "extends", we can specify what type <T> can be. (here is number or string)
---------------------------------------------------------------------
class SimpleMath<T extends number | string>{                // it can take either number or string.
    baseValue: T;
    multiplyValue: T;
    calculate(): number{
        return +this.baseValue * +this.multiplyValue;       // becasue TS knows baseValue still can be sth like string instead of number
                                                            // we should add a "+" before "this.baseValue" and "this.multiplyValue", in // order to make it work. so it add the previus value to the present value.
    }
}

const simpleMath = new SimpleMath<string>();    // because we created our object as <string> type, so we should pass strings to it.
simpleMath.baseValue = "10";                    // string   -   it can't be number, because simpleMath only takes string,
simpleMath.multiplyValue = "20";                // string   -   
console.log(simpleMath.calculate());            // 200
---------------------------------------------------------------------
we also can have multiple generic types.
---------------------------------------------------------------------
class SimpleMath<T extends number | string, U extends number | string>{         // T can take either number or string,
                                                                                // U can take either number or string.
    baseValue: T;           // type of T
    multiplyValue: U;       // type of U
    calculate(): number{
        return +this.baseValue * +this.multiplyValue;       // becasue TS knows baseValue still can be sth like string instead of number
                                                            // we should add a "+" before "this.baseValue" and "this.multiplyValue",in 
                                                            // order to make it work. so it add the previus value to the present value.
    }
}

const simpleMath = new SimpleMath<string,number>();    // the fisrt argument should be string, the second one should be number
simpleMath.baseValue = "10";                           // string   -   it can't be number
simpleMath.multiplyValue = 20;                         // number   -   it can't be string
console.log(simpleMath.calculate());                   // 200
---------------------------------------------------------------------
/* Example for generic class, and how to use generics */

---------------------------------------------------------------------
class MyMap<T> {
  private map: { [key: string]: T } = {};       // this is where we wanna store our map

  setItem(key: string, item: T) {               // set any item as we want into the map
    this.map[key] = item;
  }

  getItem(key: string) {                        // get 1 item at the time
    return this.map[key];
  }

  clear() {                                     // clear the map
    this.map = {};
  }

  printMap() {                                  print all the map with "for in" loop
    for (let key in this.map) {
      if (this.map.hasOwnProperty(key)) {   
        const element = this.map[key];
        console.log(key, element);
      }
    }
  }
}

const numberMap = new MyMap<number>();          // we just pass numbers as arguments
numberMap.setItem("Apples", 10);
numberMap.setItem("Bananas", 2);
console.log(numberMap.getItem("Apples"));
numberMap.printMap();
numberMap.clear();
numberMap.printMap();

const stringMap = new MyMap<string>();          // we just pass strings as arguments
stringMap.setItem("Apples", "10");
stringMap.setItem("Bananas", "2");
console.log(stringMap.getItem("Apples"));
stringMap.printMap();
stringMap.clear();
stringMap.printMap();
---------------------------------------------------------------------
/*** Decorator ***/
we use decorators to for example, lock some information about the constructor of this calss 
a decorator is basically is a function we create that attached to a class and takes one argument by TS according to what this 
decorator, attached to. in bellow, as we want the decorator for the constructor of the class, we pass constructor to it.
we can name it constructorFn, that it's type is "function" and then we can code what we want the decorator to do for us.
in order to attach the decorator we create, to the class, we use this syntax:  @decoratorName
so just before the class, we write an atsign "@" and then the name of that decorator.
*** in order to use decorators in the code, we should add the config to the tsconfig.json file like this:
"experimentalDecorators": true
---------------------------------------------------------------------
function logged(constructorFn: Function) {      // Function is a type 
  console.log(constructorFn);
}

@logged
class Person {
  constructor() {
    console.log("Hi");
  }
}
-----------
in the console we'll see the constructor:
ƒ Person() {
        console.log("Hi"); 
}
---------------------------------------------------------------------
/* Factory */
we also can use Factories when we want to manage if the decorator should be attached or not. bellow, we have
a decorator which takes a boolean argument (true of false) that "true" means it should attach and "false"
returns null, so it shouldn't. 

"logging" is not really a decorator, because TS doesn't pass anything to it, but if it receives "true",
it refers to the decorator and the decorator will attach.
---------------------------------------------------------------------
function logged(constructorFn: Function) {      // Function is a type 
  console.log(constructorFn);
}

@logged
class Person {
  constructor() {
    console.log("Hi");
  }
}

function logging(value: boolean) {
  return value ? logged : null;         // check if true passed, looged will attach
}

@logging(true)          // pass true or false
class Car {

}
---------------------------------------------------------------------
to use decorators as more useful features, we can create a function for prototype of the class constructor.
so any object has created based on this class, will have this function in their prototype.
(by saying prototype, we mean the parent class of all objects)
---------------------------------------------------------------------
function printable(constructorFn: Function) {
  constructorFn.prototype.print = function () {         // this print method, will print the class
    console.log(this);
  }
}

@printable
class Plant {
  name = "Green Plant"
}

const plant = new Plant();  
(<any>plant).print();               // we should explicitly specify the type of any in order to prevent error.
---------------------------------------------------------------------
we can also use multiple decorator for a class.
---------------------------------------------------------------------
function logged(constructorFn: Function) {      // decorator number 1
  console.log(constructorFn);
}

function logging(value: boolean) {
  return value ? logged : null;         
}

function printable(constructorFn: Function) {
  constructorFn.prototype.print = function () {  // decorator number 1
    console.log(this);
  }
}

@logging(true)                                   // use 2 decorators for a class
@printable
class Plant {
  name = "Green Plant"
}

const plant = new Plant();  
(<any>plant).print(); 
---------------------------------------------------------------------
/* Method decorator */
we can use decorators or factories for adding them to any function of a class.(not just constructor)
here we want to decide if one of the function should be editable or not editable. so we will build a 
factory named editable, and it will be attached to the method of the class
this function takes 3 arguments:
target : which might be static or instantiate(represented by instance), so we assign "any" to it
propName : which is the name of the property
descriptor : we pass the descriptor as the third argument, it makes the property, configurable,enumerable
,writable,assign a value,etc...
---------------------------------------------------------------------

function editable(value: boolean) {
  return function(target: any, propName: string, descriptor: PropertyDescriptor) {
    descriptor.writable = value;        // if it was true, this metohd can be editable.
  };
}

class Project {
  projectName: string;

  constructor(name: string) {
    this.projectName = name;
  }

  @editable(false)                  // it cannot be editable
  calcBudget() {
    console.log(1000);
  }
}

const project = new Project("Super Project");
project.calcBudget();
project.calcBudget = function() {       // doesn't work
  console.log(2000);
};
project.calcBudget();
------------------------------
it returns:
1000
1000
---------------------------------------------------------------------
/* property decorator */

TypeScript can't access properties as the same way as accessing methods,
just like method decorators, we can access the old target and propName, but we cannot access the descriptor
because TS can't access it, but we can return the descriptor
so we can set the descriptor but we can't access the old one or the existing one

---------------------------------------------------------------------
function overwritable(value: boolean) {
  return function(target: any, propName: string): any {     // becasue of we want to return the newDescripter,
                                                            // we should specify the type as "any"
    const newDescripter: PropertyDescriptor = {             // setting up descriptor
      writable: value
    };
    return newDescripter;
  };
}

class Project {
  @overwritable(false)
  projectName: string;

  constructor(name: string) {
    this.projectName = name;
  }

  @editable(false)
  calcBudget() {
    console.log(1000);
  }
}

const project = new Project("Super Project");
console.log(project);       // it won't show "Super Project" as the name of project
                            // becasue it's not assignable
---------------------------------------------------------------------
/* Parameter decorator */
it takes target which refers to the constructor or prototype of the function, then we have methodName and paramIndex
which shows the position of parameter in the function like: 0,1,2,...
---------------------------------------------------------------------

function printInfo(target: any, methodName: string, paramIndex: number) {
  console.log("Target: ", target);              // > Object {}
  console.log("MethodName: ", methodName);      // > printStudentNumbers
  console.log("ParamIndex: ", paramIndex);      // > 1
}

class Course {
  name: string;

  constructor(name: string) {
    this.name = name;
  }

  // we specified "@printInfo" before the second parameter
  printStudentNumbers(mode: string, @printInfo printAll: boolean) {
    if (printAll) {
      console.log(10000);
    } else {
      console.log(2000);
    }
  }
}

const course = new Course("Super Course");
course.printStudentNumbers("anything", true);
---------------------------------------------------------------------
decorators also used for metadatas.
---------------------------------------------------------------------
//*** importing library ***//

most of the time, our project is not compeletly based on TS, becasue we might use a third party library in
our code like jQuery. if we use that, we suddenly loose all of the types features. but we wanna use a way to
make sure what types jQuery would use if it was based on TS (Not JS).
so in console, we have: $ npm i jquery --save
in ordet to import a third party like jQuery, maybe we have the code bellow in the app.ts:
---------------------------------------------------------------------
import "jQuery";
$("#app").css({ "backgournd-color": "green" });
---------------------------------------------------------------------
but it won't work and give us this error:
error : Cannot find name '$'

becasue we actually need to specify the path of this module, manually. so we should add this configuration 
to the SystemJS
so in index.HTML, we have:
---------------------------------------------------------------------
<script>
      // set our baseURL reference path
      SystemJS.config({
        map:{
          "jQuery":"node_modules/jquery/dist/jquery.min.js"
        },
        baseURL: "/",
        packages: {
          "/": {
            defaultExtension: "js"
          }
        }
      });

      // loads /js/main.js
      SystemJS.import("app.js");
</script>
---------------------------------------------------------------------
it means in order to add any library,we should map them by SystemJS, in above, the kye("jQuery" )
is the name we will import in app.ts, the value ("node_modules/jquery/dist/jquery.min.js") is the actual path of library

furthermore, we should wirte a declaration file for how jQuery would be like, if it was in TS based.
but we use alternative files, which are written by other people instead of writing them by ourselves.
if we search "definitelytyped" in Google, we find a github page with all third party library codes based on TS

for jQuery, we can simply search "definitelytyped jquery" and then we will find jquery.d.ts file, this is the translation
of jQuery for TS.
then we shoud add this file, to the root of our project directory in order to work.
or we can install npm module: $ npm install @types/jquery;  -  it has all types.
then:
---------------------------------------------------------------------
import "jQuery";
// import $ = require("jQuery");
// import $ from "jquery";
$("#app").css({ "backgournd-color": "green" });
---------------------------------------------------------------------
but in real project, we have many third party libraries,better solution is install npm typings globally
$ sudo npm i -g typings
so we don't need sth like jQuery.d.ts anymore.
with typings, we can now download any TS file declaration. for jquery let's say:
$ typings install dt~jquery --global --save

we wanna install "jquery" by "typings". for downloading any definitely typed repository (".d.ts" file),
we should add "dt~" before the name of the npm package (here is jquery).
then we have "--global" which install jquery globally in all of our files in this particular project.
(not installing it globally on our machine).
then we add --save in order to add it to the package.json file, so with a simple "npm install",
user can access all the features.

*** but Typings is deprecated in favor of NPM @types!

*** so the best solution is using @types , it help us to install declaration file for any libraries, and it 
save all these files exactly in the "/node_modules/@types" so importing all these libraries will be easier.

for installing library like jquery, we have:
$ npm i @types/jquery --save-dev

in "/node_modules/types/jquery/dist/jquery.slim.d.ts" we can see that jquery exported like this:
export = jQuery;

so for importing this package to the app.ts file, we can have one of these options:
---------------------------------------------------------------------
import "jQuery";
or
import $ from "jQuery";
or
import jQuery from "jQuery";
or
import $ = require("jQuery");
or
etc - // because it exported as default export, we can name it anything while importing, but $ & jQuery is more common
---------------------------------------------------------------------
so we have:
---------------------------------------------------------------------
import $ = require("jQuery");

$("#app").css("background-color", "green");
$("p").css("background-color", "yello");
---------------------------------------------------------------------
for specifying which ts file in our project should gets compiled, we should change tsconfig.json file
where we have exclude property.
so what does $tsc command do, if we run it like this?
it basically looks at tsconfig.json file (which has been created by $tsc --init), when we have exclude node
so when we have 
--------------------------------------
"exclude": [
    "node_modules"
]
--------------------------------------
tsc should compile all the files in this folder, except node_modules file
an alternative for excluding, is explicitly say which file should be included,so we can use "files" instead of exclude
just like:
--------------------------------------
"files": [
    "app.ts",
    "./typings/index.d.ts"
]
--------------------------------------
an alternative is compile certain files with tsc=> $tsc app.ts
so in this case, you can't use your config file
The "exclude" property defaults to excluding the node_modules, bower_components, jspm_packages and <outDir> directories when not specified.

when our tsconfig.json file is not at the current directory, we can tell tsc where to find it:
--------------------------------------
$tsc --project config/tsconfig.json
or
$tsc --p config/tsconfig.json
--------------------------------------
so it gets tsc, then "--project" or "--p", then the path to tsconfig.json
---------------------------------------------------------------------
How to combine TypeScript with Gulp:
let's say we have gulp installed in our node_modules by: $npm install --save-dev gulp gulp-typescript
so now we can use gulp instead of tsc command to compile TS code
at first we should make a file to configer our gulp workflow or task runner named: gulpfile.js
in this file, we have:
---------------------------------------------------------------------
var gulp = require('gulp');                            // importing gulp
var ts = require('gulp-typescript');                   // importing gulp-typescript

// we also should specify tsconfig.json file
var tsProject = ts.createProject("tsconfig.json");     // we use "ts" as TypeScript package and call createProject() on it,
                                                       // and we pass the path to tsconfig.json file to it

// now we run the gulp task here and we name it typescript
gulp.task("typescript",function(){      // in this task, we return all ts files and let the tsconfig.json ,
  return tsProject.src()                // contorl which file should be compiled
            .pipe(ts(tsProject))        // then we pipe another task,and in that, we use "ts" or "gulp-typescript" package as a method
            .pipe(gulp.dest(""));       // an to this method pass tsconfig.json again
// the code above tells the tsconfig.json to resolve all ts files, and then uses the TypeScript compiler,
// and compile all these files, taking the tsProject (or "tsconfig") into account 
// and at the last step, output it into root folder
});

// we can now add another task name watch for watching command, and we pass all ts files to it, just like $tsc -w

gulp.task("watch",function(){
  gulp.watch("*.ts","typescript")
});

// and set the default task

gulp.task("default",["watch"]);
---------------------------------------------------------------------
then we can go to package.json file and in script brace, write:
---------------------------------------------------------------------
"scripts":{
..
..
"build":"gulp"
}
---------------------------------------------------------------------
so with having: $npm run build , gulp will work
---------------------------------------------------------------------
/*** webpack ***/
how to get webpack to compile your typescript code
so we should install webpack and ts-loader. we use ts-loader in webpack to compile ts code:
$ npm i webpack ts-loader --save-dev

then we should get rid of systemJS in index.html file, because now we use webpack to load our files and bundle them
and don't need systemjs
so we should import "bundle.js" file into index.html. this is the file which webpack is gonna build for us
and in tsconfig.json file also, we don't need to exclude anything, becasue webpack will take care of it.
even we can delete "sourceMap": false and "module": "commonjs" just becasue of webpack

then we should build a file name: "webpack.config.js" to hold webpack configeration:
---------------------------------------------------------------------
module.exports = {
  entry: "./app.js",                         // set the entry file
  output: {
    filename: "bundle.js"                    // specify the output file name
  },
  module: {
    rules: [
      // specifing loaders
      { test: /\.ts$/, loader: "ts-loader" } // we want to test all our TypeScript files ending with ".ts"
    ]
  }
};
---------------------------------------------------------------------
in package.json we have two more scripts:
---------------------------------------------------------------------
"scripts": {
    "build":"webpack -d --watch",     // build a bundle file with watch mode for development
    "build:prod":"webpack -p"         // build a bundle file for production without any sourceMap file and ...
  },
---------------------------------------------------------------------
sometimes we should install TypeScript loacally not globally. so $npm i typescript --save-dev
it also may take errors from our imported libraries, we should pay attention to it that anytime we wanted to import
a library, we should use NodeJS syntax (means require();). becasue webpack only understand ES5 syntax and NodeJS syntax
for example: import $ = require("jQuery");
so then we have: $npm run build
and we also should bring this line
      <script src="dist/bundle.js"></script>
to the last line of <body> tag, so the code will work and if we change it, it will be changed as it's on watch mode. 

---------------------------------------------------------------------
/*** React + TS ***/
first install: $npm i react react-dom --save
then we should install type declarations for them
the best solution is using @types, so:
$npm i @types/react @types/react-dom --save
then we need to install webpack
$npm i webpack ts-loader --save-dev
and also we need a server, we can use the webpack development server but locally, we can use lite-server
$npm i lite-server --save-dev
now we can wirte our react code: so we build a folder ==> ./src/components
and then we have files with .tsx postfix. for example index.tsx
then we have a webpack configeration like this:
---------------------------------------------------------------------
module.exports = {
  entry: './src/index.tsx',   // the file webpack should look at to compile
  output: {
    filename: 'bundle.js' // specify the output file name
  },
  devtool: 'source-map',
  resolve: {
    // resolve file extensions - it holds an array of extensions TS should be able to identify
    // we need to add it because sometimes we add files with no extensions and webpack should add extensions dynamically to them
    extensions: [
      '*', // the first one is no extension, becuse for some files we already specify them in file name
      '.ts', // next is for .ts files
      '.tsx', // next is for .tsx files
      '.js' // because sth like react was built with javascript
    ]
  },
  module: {
    rules: [
      // specifing loaders
      { test: /\.tsx$/, loader: 'ts-loader' } // we want to test all our TypeScript files ending with ".tsx"
    ]
  }
};


---------------------------------------------------------------------
and in ./src/components/Home.tsx we have:
---------------------------------------------------------------------
import * as React from "react";   // importing react

interface HomeProps {   // set the property types
  name: string;
  age: number;
}

// this should be a generic type so it takes 2 arguments: interface (or format of props of this component) and state
// so we pass HomeProps interface and empty object as state    
export class Home extends React.Component<HomeProps, {}> {
  render() {
    return (
      <div>
        Hello there {this.props.name}, are you {this.props.age}, right?
      </div>
    );
  }
}
---------------------------------------------------------------------
and in src/index.tsx we have:
---------------------------------------------------------------------
import * as React from "react";
import * as ReactDOM from "react-dom";

import { Home } from "./components/Home";
// we also should have this: <div id="app"></div> in index.html
ReactDOM.render(<Home name="Max" age={27} />, document.getElementById("app"));

---------------------------------------------------------------------
***** 
tips:

for making a module work, we should install both npm module and its type declaration.
for example about React, we should install both react and @types/react, because react is actual module but
@types/react is type information for typescript.
The type information has no functionality by its own, so you need to install both.
so we should install both jquery and @types/jquery or react-dom and @types/react-dom

*** also we need to install typescript locally as devDependencies in package.json file, because the ts-loader uses it's local copy
of typescript in this project 

*** also we should change tsconfig.json file like this:
---------------------------------------------------------------------
"jsx": "react" /* Specify JSX code generation: 'preserve', 'react-native', or 'react'. */,
---------------------------------------------------------------------
it tells typescript what to do with JSX syntax in the .tsx files

then we should compile the code with webpack, so we should add a configeration into the package.json:
---------------------------------------------------------------------
"scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "lite-server",
    "build": "webpack -d --watch",
    "build:prod": "webpack -p"
},
---------------------------------------------------------------------
so we then run both "$npm run start" and "$npm run build" at the same time